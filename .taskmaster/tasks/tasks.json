{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialisation du projet Angular avec structure de base",
        "description": "Créer un nouveau projet Angular 19.2 avec les configurations de base et l'architecture standalone components",
        "details": "Utiliser Angular CLI pour créer le projet avec 'ng new youtube-looper --routing --style=scss --standalone'. Configurer angular.json pour utiliser SCSS par défaut. Nettoyer les fichiers générés par défaut et créer la structure de dossiers selon les conventions du projet : src/app/features/, src/app/shared/, src/app/core/. Configurer TypeScript en mode strict. Installer les dépendances nécessaires.",
        "testStrategy": "Vérifier que 'ng serve' démarre sans erreur, que le projet utilise Angular 19.2, que la structure de dossiers est correcte et que SCSS est configuré par défaut.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Intégration de l'API YouTube IFrame Player",
        "description": "Configurer l'API YouTube IFrame Player et créer un service Angular pour gérer l'intégration",
        "details": "Créer un service YouTubePlayerService utilisant l'API YouTube IFrame Player. Charger dynamiquement le script YouTube API dans index.html ou via le service. Implémenter les méthodes de base : loadVideo(), playVideo(), pauseVideo(), getCurrentTime(), getDuration(). Utiliser les signals Angular pour gérer l'état du lecteur. Gérer les événements onReady, onStateChange. Ajouter la gestion d'erreurs pour les vidéos privées/indisponibles.",
        "testStrategy": "Tester le chargement d'une vidéo YouTube valide, vérifier que les contrôles natifs fonctionnent, tester avec une URL invalide pour confirmer la gestion d'erreur.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Charger dynamiquement l'API YouTube IFrame Player",
            "description": "Implémenter le chargement dynamique du script YouTube API et initialiser l'environnement d'intégration",
            "dependencies": [],
            "details": "Créer une méthode loadYouTubeAPI() qui injecte dynamiquement le script https://www.youtube.com/iframe_api dans le document. Utiliser un Promise pour gérer l'état de chargement et éviter les multiples chargements. Implémenter une variable globale onYouTubeIframeAPIReady pour capturer la callback d'initialisation. Gérer les erreurs de chargement du script et les timeouts.",
            "status": "done",
            "testStrategy": "Vérifier que le script YouTube API se charge correctement, tester les scénarios d'erreur de réseau, valider qu'une seule instance du script est chargée même avec multiples appels"
          },
          {
            "id": 2,
            "title": "Créer le service YouTubePlayerService avec architecture signals",
            "description": "Développer le service principal avec la gestion d'état basée sur les signals Angular",
            "dependencies": [
              "2.1"
            ],
            "details": "Créer YouTubePlayerService injectable avec signals pour : playerState (unloaded/loading/ready/playing/paused/error), currentVideo (videoId, title, duration), playerInstance. Implémenter le pattern de service avec computed signals pour les états dérivés. Utiliser takeUntilDestroyed pour la gestion automatique des subscriptions. Initialiser le service avec la méthode d'injection moderne inject().",
            "status": "done",
            "testStrategy": "Tester l'initialisation du service, vérifier les states des signals, valider la gestion mémoire avec takeUntilDestroyed"
          },
          {
            "id": 3,
            "title": "Implémenter les méthodes de contrôle vidéo de base",
            "description": "Développer les méthodes fondamentales de contrôle du lecteur YouTube",
            "dependencies": [
              "2.2"
            ],
            "details": "Implémenter loadVideo(videoId: string) avec extraction d'ID depuis URL complète, playVideo(), pauseVideo(), getCurrentTime(), getDuration(), seekTo(seconds: number). Chaque méthode doit vérifier l'état du player avant exécution. Utiliser des Promises pour les opérations asynchrones. Intégrer la mise à jour des signals correspondants après chaque opération.",
            "status": "done",
            "testStrategy": "Tester chaque méthode individuellement, vérifier les retours d'erreur pour player non initialisé, valider la synchronisation des signals avec l'état réel du player"
          },
          {
            "id": 4,
            "title": "Gérer les événements YouTube Player (onReady, onStateChange)",
            "description": "Implémenter la gestion des événements natifs du lecteur YouTube et synchroniser avec les signals",
            "dependencies": [
              "2.3"
            ],
            "details": "Créer les callbacks onPlayerReady() et onPlayerStateChange() pour capturer les événements YouTube. Mapper les états YouTube (YT.PlayerState) vers les signals internes. Émettre des events personnalisés pour les composants externes. Implémenter onPlayerError() pour capturer les erreurs de lecture. Synchroniser automatiquement currentTime via interval quand en lecture.",
            "status": "done",
            "testStrategy": "Tester les transitions d'état (loading->ready->playing->paused), vérifier la synchronisation temps réel, valider la capture d'événements d'erreur"
          },
          {
            "id": 5,
            "title": "Implémenter la gestion d'erreurs pour vidéos indisponibles",
            "description": "Développer un système robuste de gestion des erreurs pour les cas d'échec de chargement vidéo",
            "dependencies": [
              "2.4"
            ],
            "details": "Créer un enum YouTubeError pour typer les erreurs (VIDEO_NOT_FOUND, PRIVATE_VIDEO, REGION_BLOCKED, etc.). Implémenter handlePlayerError() avec mapping des codes d'erreur YouTube vers messages utilisateur français. Utiliser un signal errorState pour exposer l'état d'erreur aux composants. Ajouter retry mechanism avec backoff exponentiel pour erreurs réseau. Logger les erreurs pour debug.",
            "status": "done",
            "testStrategy": "Tester avec vidéo inexistante, vidéo privée, vidéo géo-bloquée, vérifier les messages d'erreur français, valider le système de retry"
          },
          {
            "id": 6,
            "title": "Chargement dynamique du script YouTube IFrame API",
            "description": "Configurer le chargement dynamique du script YouTube IFrame API dans l'application Angular",
            "dependencies": [],
            "details": "Créer une fonction utilitaire pour charger dynamiquement le script YouTube IFrame API (https://www.youtube.com/iframe_api). Implémenter une vérification pour éviter le double chargement. Gérer la promesse de chargement avec resolve/reject. Ajouter la fonction dans un service ou directement dans YouTubePlayerService. S'assurer que window.onYouTubeIframeAPIReady est correctement configurée.",
            "status": "done",
            "testStrategy": "Vérifier que le script se charge une seule fois, tester que l'API est disponible après chargement, valider le callback onYouTubeIframeAPIReady"
          },
          {
            "id": 7,
            "title": "Création du service YouTubePlayerService avec signals",
            "description": "Développer le service principal pour encapsuler l'API YouTube IFrame Player avec la gestion d'état par signals",
            "dependencies": [
              "2.6"
            ],
            "details": "Créer YouTubePlayerService injectable avec providedIn: 'root'. Définir les signals : playerState (loading, ready, playing, paused, error), videoId, currentTime, duration, isLoaded. Créer les interfaces TypeScript pour les événements YouTube. Implémenter la méthode initializePlayer() qui instancie YT.Player. Utiliser takeUntilDestroyed pour la gestion du cycle de vie. Ajouter les types YouTube dans un fichier de déclarations.",
            "status": "done",
            "testStrategy": "Vérifier l'injection du service, tester l'initialisation du player, valider que les signals se mettent à jour correctement"
          },
          {
            "id": 8,
            "title": "Implémentation des méthodes de contrôle vidéo de base",
            "description": "Ajouter les méthodes essentielles pour contrôler la lecture vidéo via l'API YouTube",
            "dependencies": [
              "2.7"
            ],
            "details": "Implémenter dans YouTubePlayerService les méthodes : loadVideo(videoId: string), playVideo(), pauseVideo(), getCurrentTime(): number, getDuration(): number, seekTo(seconds: number). Chaque méthode doit vérifier que le player est prêt avant exécution. Gérer les erreurs avec try/catch. Mettre à jour les signals correspondants après chaque action. Ajouter des guards pour vérifier l'état du player.",
            "status": "done",
            "testStrategy": "Tester chaque méthode individuellement, vérifier que getCurrentTime et getDuration retournent des valeurs correctes, valider la gestion d'erreur"
          },
          {
            "id": 9,
            "title": "Gestion des événements YouTube Player (onReady, onStateChange)",
            "description": "Implémenter la gestion des événements du lecteur YouTube pour synchroniser l'état de l'application",
            "dependencies": [
              "2.8"
            ],
            "details": "Configurer les event handlers onReady et onStateChange lors de l'initialisation du player. Dans onReady, mettre à jour le signal playerState à 'ready' et récupérer la durée. Dans onStateChange, mapper les états YouTube (PLAYING, PAUSED, ENDED, etc.) vers les signals internes. Implémenter un interval pour mettre à jour currentTime pendant la lecture. Gérer l'événement onError pour les erreurs de lecture.",
            "status": "done",
            "testStrategy": "Vérifier que onReady se déclenche, tester les changements d'état lors de play/pause, valider la mise à jour du temps courant"
          },
          {
            "id": 10,
            "title": "Gestion d'erreurs pour vidéos privées et indisponibles",
            "description": "Implémenter la gestion complète des erreurs YouTube avec feedback utilisateur approprié",
            "dependencies": [
              "2.9"
            ],
            "details": "Étendre la gestion d'erreurs dans onError pour identifier les types d'erreurs YouTube : vidéo privée (code 101), vidéo supprimée (code 100), géo-blocage (code 150), vidéo non trouvée (code 5). Créer un signal errorMessage pour stocker les messages d'erreur localisés en français. Implémenter clearError() pour réinitialiser l'état d'erreur. Ajouter des méthodes helper pour détecter si une vidéo est disponible. Prévoir un fallback pour les erreurs non identifiées.",
            "status": "done",
            "testStrategy": "Tester avec des URLs de vidéos privées, supprimées, géo-bloquées, vérifier l'affichage des messages d'erreur appropriés, valider la remise à zéro des erreurs"
          }
        ]
      },
      {
        "id": 3,
        "title": "Composant de saisie d'URL YouTube avec validation",
        "description": "Créer le composant pour saisir et valider les URLs YouTube avec auto-focus et feedback utilisateur",
        "details": "Créer UrlInputComponent avec un formulaire réactif Angular. Implémenter la validation d'URL YouTube avec regex pour détecter les formats youtube.com/watch?v= et youtu.be/. Ajouter auto-focus avec ViewChild et ngAfterViewInit. Créer un placeholder avec exemple d'URL. Utiliser debounceTime pour éviter les validations excessives. Intégrer avec YouTubePlayerService pour charger automatiquement les vidéos valides. Afficher des messages d'erreur clairs pour les URLs invalides.",
        "testStrategy": "Tester avec différents formats d'URLs YouTube (youtube.com, youtu.be, avec/sans paramètres), vérifier l'auto-focus, valider les messages d'erreur pour URLs invalides.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Composant lecteur vidéo avec contrôles natifs",
        "description": "Créer le composant pour afficher la vidéo YouTube avec l'API IFrame et les contrôles natifs",
        "details": "Créer VideoPlayerComponent qui utilise YouTubePlayerService. Implémenter l'affichage du lecteur IFrame avec les contrôles natifs YouTube activés (controls: 1). Gérer les états de chargement, erreur, et lecture. Utiliser signals pour réagir aux changements d'état. Implémenter la communication bidirectionnelle avec le service pour exposer les méthodes nécessaires (getCurrentTime, getDuration, etc.). Responsive design pour différentes tailles d'écran.",
        "testStrategy": "Vérifier l'affichage correct de la vidéo, tester les contrôles natifs (play, pause, volume, plein écran), valider la responsivité sur mobile/desktop.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure de base du VideoPlayerComponent",
            "description": "Générer et configurer le composant VideoPlayer avec l'architecture de base et l'injection du YouTubePlayerService",
            "dependencies": [],
            "details": "Créer VideoPlayerComponent dans features/video-player/ui/video-player/ avec ng generate. Configurer l'injection du YouTubePlayerService via inject(). Définir les signals de base pour l'état du lecteur (isLoading, hasError, currentVideoId). Créer le template HTML de base avec un conteneur pour le lecteur IFrame. Configurer les styles SCSS responsive avec des breakpoints mobile/desktop.",
            "status": "done",
            "testStrategy": "Vérifier que le composant se compile correctement et s'affiche sans erreur dans l'application"
          },
          {
            "id": 2,
            "title": "Implémenter l'affichage du lecteur IFrame YouTube",
            "description": "Intégrer l'API YouTube IFrame Player dans le composant avec les contrôles natifs activés",
            "dependencies": [
              "4.1"
            ],
            "details": "Ajouter un div conteneur avec un ID unique pour le lecteur YouTube. Utiliser ViewChild pour référencer l'élément DOM. Dans ngAfterViewInit, appeler le service pour initialiser le lecteur avec les paramètres : controls: 1, showinfo: 0, rel: 0. Configurer la taille responsive du lecteur (16:9 ratio). Gérer les événements onReady du lecteur pour confirmer l'initialisation.",
            "status": "done",
            "testStrategy": "Tester l'affichage du lecteur avec une URL valide, vérifier que les contrôles natifs (play, pause, volume, plein écran) sont visibles et fonctionnels"
          },
          {
            "id": 3,
            "title": "Gérer les états de chargement et d'erreur",
            "description": "Implémenter la gestion des différents états du lecteur (chargement, erreur, prêt) avec feedback utilisateur",
            "dependencies": [
              "4.2"
            ],
            "details": "Créer des signals pour isLoading, hasError, errorMessage. Écouter les événements onStateChange du lecteur pour détecter les états BUFFERING, PLAYING, PAUSED, ENDED. Afficher un spinner de chargement pendant le buffering. Créer des messages d'erreur pour vidéos privées, indisponibles, ou géo-bloquées. Implémenter un mécanisme de retry pour les erreurs temporaires.",
            "status": "done",
            "testStrategy": "Tester avec une vidéo valide, une vidéo privée, et une URL inexistante pour valider tous les cas d'erreur et états de chargement"
          },
          {
            "id": 4,
            "title": "Implémenter la communication bidirectionnelle avec YouTubePlayerService",
            "description": "Exposer les méthodes du lecteur et synchroniser l'état entre le composant et le service",
            "dependencies": [
              "4.3"
            ],
            "details": "Créer des méthodes publiques : getCurrentTime(), getDuration(), seekTo(), getVideoData(). Utiliser des signals computed pour exposer l'état du lecteur (currentTime, duration, playbackState). Implémenter un système d'événements pour notifier les changements d'état au service parent. Ajouter des méthodes pour contrôler la lecture : play(), pause(), stop().",
            "status": "done",
            "testStrategy": "Vérifier que getCurrentTime() retourne la position correcte, tester seekTo() pour naviguer dans la vidéo, valider la synchronisation des états"
          },
          {
            "id": 5,
            "title": "Optimiser la responsivité et finaliser l'interface",
            "description": "Perfectionner le design responsive et l'intégration visuelle du composant dans l'application",
            "dependencies": [
              "4.4"
            ],
            "details": "Implémenter CSS Grid/Flexbox pour un layout responsive optimal. Ajouter des media queries pour mobile (< 768px), tablette (768px-1024px), et desktop (> 1024px). Configurer l'aspect ratio 16:9 avec CSS aspect-ratio ou padding-bottom technique. Ajouter des styles pour les états de chargement et d'erreur. Optimiser les performances avec OnPush change detection strategy.",
            "status": "done",
            "testStrategy": "Tester sur différentes tailles d'écran, vérifier l'aspect ratio en mode portrait/paysage, valider l'accessibilité avec navigation clavier"
          }
        ]
      },
      {
        "id": 5,
        "title": "Service de gestion des boucles temporelles",
        "description": "Créer un service pour gérer la logique de boucle avec start/end times et la répétition automatique",
        "details": "Créer LoopService avec signals pour gérer startTime, endTime, isLoopActive. Implémenter la logique de surveillance temporelle avec interval pour vérifier la position courante. Quand currentTime >= endTime, rediriger vers startTime. Méthodes : setStartTime(), setEndTime(), toggleLoop(), getCurrentLoop(). Utiliser takeUntilDestroyed pour nettoyer les intervalles. Intégrer avec YouTubePlayerService pour contrôler la position de la vidéo. Gérer un seul loop actif à la fois (V1).",
        "testStrategy": "Tester la création d'une boucle avec start/end, vérifier que la vidéo redémarre automatiquement à startTime après avoir atteint endTime, valider l'activation/désactivation de la boucle.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Interface timeline interactive avec poignées start/end",
        "description": "Créer un composant timeline avec deux poignées draggables pour définir visuellement les bornes de boucle",
        "details": "Créer TimelineComponent avec une barre de progression visuelle. Implémenter deux poignées draggables (start/end) avec HTML5 drag & drop ou mouse events. Afficher le temps au-dessus de chaque poignée pendant le drag. Zone colorée entre start et end pour visualiser la boucle. Synchroniser avec LoopService pour mettre à jour les temps. Responsive avec touch events pour mobile. Contraintes : startTime < endTime, bornes dans la durée de la vidéo.",
        "testStrategy": "Tester le drag des poignées, vérifier l'affichage des temps, valider la zone colorée, tester sur écran tactile, vérifier les contraintes de validation.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure du composant TimelineComponent",
            "description": "Générer le composant TimelineComponent avec sa structure de base, l'intégrer dans l'architecture existante et préparer l'injection du LoopService",
            "dependencies": [],
            "details": "Créer TimelineComponent dans src/app/features/video-controls/ui/timeline/ en suivant les conventions du projet. Générer les fichiers component.ts, component.html, component.scss avec architecture standalone. Ajouter l'injection du LoopService et YouTubePlayerService. Créer le fichier index.ts pour barrel export. Mettre en place les signals de base pour startTime, endTime, duration et isActive.",
            "status": "done",
            "testStrategy": "Vérifier la génération correcte du composant, l'injection des services, la compilation sans erreurs et l'affichage de base dans l'interface"
          },
          {
            "id": 2,
            "title": "Implémenter la barre de progression visuelle avec zone colorée",
            "description": "Créer l'interface visuelle de la timeline avec une barre de progression et zone colorée entre les bornes start/end",
            "dependencies": [
              "6.1"
            ],
            "details": "Créer le template HTML avec une barre de progression SVG ou Canvas. Implémenter l'affichage de la position courante de la vidéo. Ajouter la zone colorée entre startTime et endTime. Utiliser les variables CSS du thème existant pour maintenir la cohérence visuelle. Synchroniser l'affichage avec la duration de la vidéo du YouTubePlayerService. Assurer la responsivité sur tous les breakpoints.",
            "status": "done",
            "testStrategy": "Valider l'affichage de la barre de progression, vérifier la zone colorée entre les bornes, tester la responsivité sur mobile/tablet/desktop"
          },
          {
            "id": 3,
            "title": "Développer les poignées draggables start et end",
            "description": "Implémenter deux poignées interactives pour définir les bornes de boucle avec drag and drop",
            "dependencies": [
              "6.2"
            ],
            "details": "Créer deux éléments draggables (poignées start/end) positionnés sur la timeline. Implémenter les event listeners pour mousedown, mousemove, mouseup. Gérer les contraintes : startTime < endTime, bornes dans [0, duration]. Synchroniser les changements avec le LoopService via setStartTime() et setEndTime(). Ajouter des styles visuels distincts pour chaque poignée. Implémenter le feedback visuel pendant le drag (cursor, hover states).",
            "status": "done",
            "testStrategy": "Tester le drag des poignées, vérifier les contraintes de validation, valider la synchronisation avec LoopService, contrôler les feedbacks visuels"
          },
          {
            "id": 4,
            "title": "Ajouter l'affichage du temps au-dessus des poignées",
            "description": "Implémenter l'affichage dynamique du temps pendant le drag des poignées avec formatage approprié",
            "dependencies": [
              "6.3"
            ],
            "details": "Créer des tooltips ou overlays qui affichent le temps (MM:SS format) au-dessus de chaque poignée. Afficher les temps pendant le drag et au survol. Implémenter une fonction de formatage du temps (secondes vers MM:SS). Positionner dynamiquement les affichages selon la position des poignées. Gérer la visibilité et les transitions CSS. Assurer la lisibilité avec les contrastes appropriés selon le thème actuel.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage des temps pendant le drag, valider le formatage MM:SS, tester la visibilité et positionnement sur différentes tailles d'écran"
          },
          {
            "id": 5,
            "title": "Implémenter le support tactile et finaliser l'intégration",
            "description": "Ajouter le support des événements tactiles pour mobile et intégrer le TimelineComponent dans l'interface principale",
            "dependencies": [
              "6.4"
            ],
            "details": "Ajouter les event listeners pour touch events (touchstart, touchmove, touchend). Adapter les calculs de position pour les interactions tactiles. Gérer les spécificités mobile (touch target size minimum 44px). Intégrer le TimelineComponent dans app-main.component.html en remplaçant le commentaire. Appliquer les styles timeline-container existants. Tester la synchronisation complète avec LoopService et YouTubePlayerService. Valider l'expérience utilisateur sur tous les appareils.",
            "status": "done",
            "testStrategy": "Tester les interactions tactiles sur mobile/tablette, vérifier l'intégration dans l'interface principale, valider la synchronisation complète avec les services, contrôler l'ergonomie sur tous les breakpoints"
          }
        ]
      },
      {
        "id": 7,
        "title": "Boutons de contrôle rapide pour la boucle",
        "description": "Implémenter les boutons 'Set Start', 'Set End' et 'Play/Stop Loop' avec indicateurs visuels et contrôle automatique de la position de lecture",
        "details": "Créer LoopControlsComponent avec trois boutons principaux : 'Set Start' (définit startTime à la position courante ET repositionne automatiquement la vidéo sur cette position), 'Set End' (définit endTime à la position courante), 'Toggle Loop' (active/désactive la boucle). NOUVEAU : Le bouton play démarre la lecture depuis startTime et boucle automatiquement entre start et end définis par Set Start/Set End. Design des boutons discret et élégant qui s'intègre parfaitement dans la page existante et au workflow avec la timeline. Boutons tactiles ≥44px selon les guidelines. Intégrer avec LoopService et YouTubePlayerService. Feedback immédiat sur les actions utilisateur.",
        "testStrategy": "Tester chaque bouton individuellement, NOUVEAU : valider que 'Set Start' repositionne automatiquement la vidéo, tester que play démarre depuis startTime et boucle automatiquement, vérifier que 'Set Start/End' utilisent la position courante, valider l'indicateur visuel de boucle, tester la taille tactile des boutons, valider l'intégration design avec la timeline existante.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le composant LoopControlsComponent avec structure de base",
            "description": "Créer le composant standalone LoopControlsComponent avec la structure HTML et SCSS de base pour les trois boutons de contrôle rapide",
            "dependencies": [],
            "details": "Générer le composant avec ng generate dans features/loop/ui/loop-controls. Créer la structure HTML avec trois boutons : 'Set Start', 'Set End' et 'Toggle Loop'. Ajouter les styles SCSS de base avec tailles tactiles minimum 44px selon les guidelines d'accessibilité. Implémenter le design discret et élégant qui s'intègre avec la page existante. Utiliser des icônes appropriées pour chaque bouton.",
            "status": "done",
            "testStrategy": "Vérifier que le composant se compile et s'affiche correctement avec les trois boutons visibles et correctement stylisés"
          },
          {
            "id": 2,
            "title": "Intégrer LoopControlsComponent avec les services existants",
            "description": "Injecter LoopService et YouTubePlayerService dans le composant et créer les méthodes de base pour chaque bouton",
            "dependencies": [
              "7.1"
            ],
            "details": "Utiliser la fonction inject() pour injecter LoopService et YouTubePlayerService. Créer les méthodes setStartTime(), setEndTime() et toggleLoop(). Implémenter les signals nécessaires pour réagir aux changements d'état. Créer les event handlers pour les clics des boutons. Préparer la structure pour la logique de repositionnement automatique.",
            "status": "done",
            "testStrategy": "Tester l'injection des services et vérifier que les méthodes sont appelées lors des clics sur les boutons"
          },
          {
            "id": 3,
            "title": "Implémenter la fonctionnalité 'Set Start' avec repositionnement automatique",
            "description": "Développer la logique du bouton 'Set Start' qui définit le startTime à la position courante ET repositionne automatiquement la vidéo sur cette position",
            "dependencies": [
              "7.2"
            ],
            "details": "Implémenter setStartTime() pour récupérer la position courante via YouTubePlayerService.getCurrentTime(), mettre à jour loopService.startTime, puis immédiatement repositionner la vidéo sur cette position avec YouTubePlayerService.seekTo(). Ajouter feedback visuel immédiat pour confirmer l'action. Gérer les cas d'erreur si la vidéo n'est pas prête.",
            "status": "done",
            "testStrategy": "Valider que Set Start récupère la position courante, met à jour le startTime dans LoopService et repositionne automatiquement la vidéo à cette position"
          },
          {
            "id": 4,
            "title": "Implémenter la fonctionnalité 'Set End' et 'Toggle Loop'",
            "description": "Développer la logique des boutons 'Set End' et 'Toggle Loop' avec indicateurs visuels d'état",
            "dependencies": [
              "7.3"
            ],
            "details": "Implémenter setEndTime() pour définir endTime à la position courante via YouTubePlayerService.getCurrentTime(). Développer toggleLoop() pour activer/désactiver la boucle via loopService.toggleLoop(). Ajouter indicateurs visuels : état actif/inactif du bouton Toggle Loop, feedback temporaire pour Set End. Implémenter la logique pour que Toggle Loop démarre la lecture depuis startTime quand activé.",
            "status": "done",
            "testStrategy": "Tester Set End avec la position courante, valider Toggle Loop pour activer/désactiver la boucle, vérifier les indicateurs visuels d'état"
          },
          {
            "id": 5,
            "title": "Finaliser l'intégration et la logique de lecture automatique",
            "description": "Compléter l'intégration avec la timeline et implémenter la logique de lecture automatique depuis startTime avec bouclage automatique",
            "dependencies": [
              "7.4"
            ],
            "details": "Intégrer LoopControlsComponent dans MainPlayerComponent. Synchroniser avec TimelineComponent pour refléter les changements de bornes. Implémenter la logique pour que le bouton play/toggle démarre la lecture depuis startTime et boucle automatiquement entre start et end. Ajouter la gestion des états : disabled quand pas de vidéo chargée, feedback sur les actions utilisateur. Optimiser les performances et nettoyer les listeners.",
            "status": "done",
            "testStrategy": "Tester l'intégration complète : vérifier que play démarre depuis startTime et boucle automatiquement, valider la synchronisation avec la timeline, tester tous les cas d'usage bout-en-bout"
          }
        ]
      },
      {
        "id": 8,
        "title": "Contrôle de vitesse de lecture avec presets",
        "description": "Implémenter les contrôles de vitesse avec boutons presets (0.5x, 0.75x, 1x) et menu déroulant pour options avancées",
        "details": "Créer SpeedControlComponent avec trois boutons presets pour les vitesses courantes (0.5x, 0.75x, 1x). Ajouter un dropdown/select pour vitesses supplémentaires (0.25x, 0.375x, 1.25x, 1.5x, 1.75x, 2x). Afficher la vitesse courante avec un indicateur visuel. Utiliser l'API YouTube setPlaybackRate(). Persister la vitesse sélectionnée dans localStorage. Intégrer avec YouTubePlayerService pour synchroniser l'état.",
        "testStrategy": "Tester chaque preset de vitesse, vérifier le menu déroulant, valider l'affichage de la vitesse courante, tester la persistance localStorage.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le composant SpeedControlComponent avec structure de base",
            "description": "Générer et configurer le composant SpeedControlComponent avec la structure de base, les imports nécessaires et l'intégration dans l'application",
            "dependencies": [],
            "details": "Utiliser Angular CLI pour générer le composant dans features/player/ui/speed-control. Créer la structure HTML de base avec conteneur pour boutons presets et dropdown. Configurer les imports standalone nécessaires (CommonModule, FormsModule). Ajouter les styles SCSS de base. Créer l'interface TypeScript pour les types de vitesse. Intégrer le composant dans PlayerControlsComponent ou directement dans AppComponent.",
            "status": "done",
            "testStrategy": "Vérifier que le composant s'affiche correctement dans l'application et que la structure HTML est bien formée"
          },
          {
            "id": 2,
            "title": "Implémenter les boutons presets de vitesse (0.5x, 0.75x, 1x)",
            "description": "Créer les trois boutons principaux pour les vitesses courantes avec gestion des clics et état actif",
            "dependencies": [
              "8.1"
            ],
            "details": "Créer un tableau des vitesses presets : [0.5, 0.75, 1.0]. Implémenter les boutons avec ngFor et gestion du clic via (click)='setSpeed(speed)'. Ajouter une classe CSS 'active' pour le bouton correspondant à la vitesse courante. Utiliser un signal currentSpeed pour gérer l'état. Implémenter la méthode setSpeed() qui appellera YouTubePlayerService.setPlaybackRate(). Styliser les boutons avec styles distinctifs et états hover/active.",
            "status": "done",
            "testStrategy": "Cliquer sur chaque bouton preset et vérifier que la vitesse de lecture change, valider l'affichage visuel de l'état actif"
          },
          {
            "id": 3,
            "title": "Développer le menu déroulant pour vitesses avancées",
            "description": "Implémenter un dropdown/select avec les vitesses supplémentaires et gestion de la sélection",
            "dependencies": [
              "8.2"
            ],
            "details": "Créer un select HTML avec les options : 0.25x, 0.375x, 1.25x, 1.5x, 1.75x, 2x. Utiliser ngModel pour la liaison bidirectionnelle avec currentSpeed signal. Implémenter (change)='onSpeedChange($event)' pour gérer la sélection. Styliser le dropdown pour correspondre au design de l'application. Ajouter une option par défaut 'Autres vitesses...' quand aucune vitesse avancée n'est sélectionnée. Synchroniser avec les boutons presets pour désactiver le dropdown quand un preset est actif.",
            "status": "done",
            "testStrategy": "Sélectionner différentes vitesses dans le dropdown et vérifier que la lecture change, tester la synchronisation avec les boutons presets"
          },
          {
            "id": 4,
            "title": "Intégrer avec YouTubePlayerService et ajouter l'indicateur visuel",
            "description": "Connecter le composant avec YouTubePlayerService pour contrôler la vitesse et afficher l'indicateur de vitesse courante",
            "dependencies": [
              "8.2",
              "8.3"
            ],
            "details": "Injecter YouTubePlayerService dans le composant. Implémenter la méthode setPlaybackRate() du service si elle n'existe pas encore. Créer un signal computed() pour afficher la vitesse courante avec format 'Xx' (ex: '0.75x'). Ajouter un indicateur visuel (badge ou texte) montrant la vitesse active près du lecteur. Gérer les erreurs si setPlaybackRate() échoue (certaines vitesses peuvent ne pas être supportées). Écouter les changements d'état du player pour synchroniser la vitesse affichée.",
            "status": "done",
            "testStrategy": "Vérifier que les changements de vitesse via l'interface affectent réellement la lecture YouTube, valider l'affichage correct de l'indicateur de vitesse"
          },
          {
            "id": 5,
            "title": "Implémenter la persistance localStorage et finaliser l'intégration",
            "description": "Ajouter la persistance de la vitesse sélectionnée et finaliser l'intégration complète avec l'application",
            "dependencies": [
              "8.4"
            ],
            "details": "Implémenter la sauvegarde de currentSpeed dans localStorage avec clé 'youtube-looper-speed'. Charger la vitesse sauvegardée au démarrage du composant avec ngOnInit(). Appliquer automatiquement la vitesse restaurée lors du chargement d'une nouvelle vidéo. Gérer les cas d'erreur (localStorage indisponible, valeur corrompue) avec fallback sur vitesse 1x. Ajouter des animations CSS pour les transitions de vitesse. Optimiser les performances avec debounce si nécessaire. Effectuer les tests finaux d'intégration avec tous les composants.",
            "status": "done",
            "testStrategy": "Changer la vitesse, recharger l'application et vérifier que la vitesse est restaurée, tester avec localStorage désactivé, valider l'intégration complète avec les autres contrôles"
          }
        ]
      },
      {
        "id": 9,
        "title": "Persistance localStorage et gestion des préférences",
        "description": "Implémenter la sauvegarde locale des boucles, vitesse, et URL pour permettre la restauration des sessions",
        "details": "Créer StorageService pour gérer localStorage. Sauvegarder : URL courante, startTime/endTime de la boucle, vitesse de lecture, état de la boucle (active/inactive). Implémenter auto-save lors des changements d'état. Ajouter une méthode de restauration au démarrage de l'application. Gérer les cas d'erreur (localStorage indisponible, données corrompues). Nettoyer les anciennes données si nécessaire. Utiliser JSON.stringify/parse pour les objets complexes.",
        "testStrategy": "Tester la sauvegarde automatique des paramètres, vérifier la restauration au rechargement de la page, valider la gestion des erreurs localStorage, tester avec plusieurs vidéos.",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Interface responsive et optimisations d'accessibilité",
        "description": "Finaliser le design responsive mobile-first et implémenter les fonctionnalités d'accessibilité",
        "details": "Implémenter CSS Grid/Flexbox pour layout responsive. Breakpoints : mobile (<768px), tablet (768px-1024px), desktop (>1024px). Optimiser pour orientation paysage sur tablette. Ajouter navigation clavier (tab index, focus visible). Implémenter couleurs contrastées selon WCAG AA. Ajouter aria-labels pour tous les contrôles. Tailles tactiles minimum 44px. Tester avec screen readers. Ajouter un toggle dark/light mode pour améliorer la lisibilité.",
        "testStrategy": "Tester sur différents appareils (mobile, tablette, desktop), valider la navigation clavier, vérifier les contrastes de couleur, tester avec lecteur d'écran, valider les orientations portrait/paysage.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Optimiser le système de responsive design avec CSS Grid/Flexbox",
            "description": "Réviser et unifier l'architecture responsive mobile-first en consolidant les breakpoints (<768px, 768px-1024px, >1024px) avec CSS Grid pour les layouts principaux et Flexbox pour les composants individuels.",
            "dependencies": [],
            "details": "Auditer le code SCSS existant dans tous les composants pour identifier les incohérences dans les breakpoints. Consolider les variables CSS pour les breakpoints dans styles.scss. Optimiser app-main.component.scss pour garantir que CSS Grid fonctionne parfaitement sur tous les breakpoints. Implémenter des containers Flexbox cohérents pour timeline, loop-controls et speed-control. Gérer spécifiquement l'orientation landscape sur tablette avec des media queries appropriées.",
            "status": "done",
            "testStrategy": "Tester sur différents appareils (mobile <768px, tablet 768px-1024px, desktop >1024px), valider l'orientation portrait/paysage sur tablette, vérifier que tous les composants utilisent les mêmes breakpoints de manière cohérente."
          },
          {
            "id": 2,
            "title": "Implémenter la navigation clavier et focus management",
            "description": "Ajouter un système complet de navigation au clavier avec tab index, focus visible et indicateurs visuels pour tous les contrôles interactifs.",
            "dependencies": [
              "10.1"
            ],
            "details": "Ajouter tabindex sur tous les éléments interactifs (boutons, input URL, timeline handles, contrôles vitesse). Implémenter focus-visible avec outline personnalisé utilisant var(--primary-color) pour maintenir la cohérence visuelle. Créer un ordre de tabulation logique : URL input → Load button → Timeline handles → Loop controls → Speed controls → Theme toggle. Ajouter des indicateurs de focus keyboard-only (pas de focus au clic souris). Gérer le focus trap pour les interactions timeline drag.",
            "status": "done",
            "testStrategy": "Tester la navigation complète au clavier avec Tab/Shift+Tab, vérifier que tous les éléments sont accessibles au clavier, valider les indicateurs focus visibles, tester le focus trap sur la timeline."
          },
          {
            "id": 3,
            "title": "Implémenter les couleurs contrastées selon WCAG AA",
            "description": "Réviser le système de couleurs existant pour garantir un contraste minimum 4.5:1 selon les standards WCAG AA et optimiser la lisibilité.",
            "dependencies": [
              "10.2"
            ],
            "details": "Auditer tous les contrastes couleur/fond dans les thèmes dark et light actuels avec des outils de validation WCAG. Ajuster les variables CSS dans styles.scss pour atteindre le ratio 4.5:1 minimum. Réviser particulièrement --text-secondary, --text-muted pour les labels et textes d'aide. Assurer que les états disabled, focus, hover maintiennent les contrastes requis. Optimiser la lisibilité des informations critiques (temps de boucle, messages d'erreur, états des boutons).",
            "status": "done",
            "testStrategy": "Utiliser des outils de validation de contraste (WebAIM, axe), tester la lisibilité dans différentes conditions d'éclairage, valider tous les états interactifs (hover, focus, disabled)."
          },
          {
            "id": 4,
            "title": "Ajouter aria-labels et améliorer la sémantique HTML pour screen readers",
            "description": "Enrichir tous les composants avec des aria-labels appropriés, role attributes et descriptions sémantiques pour optimiser l'expérience avec les lecteurs d'écran.",
            "dependencies": [
              "10.3"
            ],
            "details": "Ajouter aria-label sur tous les boutons sans texte explicite (timeline handles, clear button, theme toggle). Implémenter aria-describedby pour les relations input/error messages. Ajouter role='slider' et aria-valuemin/max/now sur les timeline handles. Enrichir les messages d'état avec aria-live pour les changements de loop status, loading states. Ajouter aria-expanded sur les composants avec états (speed control dropdown). Créer des descriptions contextuelles avec sr-only classes pour navigation complexe.",
            "status": "done",
            "testStrategy": "Tester avec NVDA, JAWS ou VoiceOver, vérifier que toutes les actions sont annoncées correctement, valider la navigation logique avec screen reader, tester les descriptions d'état et changements dynamiques."
          },
          {
            "id": 5,
            "title": "Optimiser les tailles tactiles et interactions touch pour mobile",
            "description": "Garantir une taille minimum de 44px pour tous les éléments interactifs et optimiser les interactions touch, particulièrement pour les timeline handles.",
            "dependencies": [
              "10.1",
              "10.4"
            ],
            "details": "Auditer toutes les tailles d'éléments interactifs et appliquer 44x44px minimum. Optimiser spécifiquement timeline handles pour le touch (augmenter zone de touch sans affecter le visuel). Ajouter des zones de touch étendues avec ::before pseudo-elements si nécessaire. Améliorer les boutons loop-controls et speed-control pour faciliter l'interaction thumb. Implémenter touch feedback (active states) sur mobile. Gérer les conflits entre touch events et drag events sur timeline.",
            "status": "done",
            "testStrategy": "Tester sur dispositifs tactiles réels (smartphone, tablette), valider la facilité d'interaction avec le pouce, mesurer les zones de touch avec outils développeur, tester le drag des timeline handles sur écrans tactiles."
          }
        ]
      },
      {
        "id": 11,
        "title": "Créer le layout principal et composant header avec mode sombre/clair",
        "description": "Développer un gabarit global minimaliste avec header contenant le titre de l'app et toggle dark/light mode, une zone principale pour le contenu, et un footer discret.",
        "details": "Créer MainLayoutComponent avec structure HTML sémantique (header, main, footer). Implémenter HeaderComponent avec titre 'YouTube Looper' et ThemeToggleComponent pour basculer dark/light mode. Créer les variables CSS custom properties dans styles.scss pour les deux thèmes : couleurs primaires, secondaires, backgrounds, textes, bordures. Utiliser CSS Grid pour le layout principal responsive. Header fixe en haut avec flexbox pour titre/toggle alignés. Zone main flexible pour accueillir les futurs composants (URL input, vidéo, contrôles). Footer minimaliste en bas avec liens essentiels. Implémenter ThemeService avec signals pour gérer l'état du thème et persister la préférence dans localStorage. Appliquer les classes CSS dynamiquement selon le thème sélectionné.",
        "testStrategy": "Vérifier l'affichage correct des trois zones (header, main, footer), tester le basculement des thèmes avec changement visuel immédiat, valider la persistance du thème au rechargement, contrôler la responsivité sur mobile/desktop, vérifier que les variables CSS sont correctement appliquées pour chaque thème.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le service ThemeService avec gestion des signaux",
            "description": "Implémenter le service responsable de la gestion du thème (dark/light) avec signals et persistance dans localStorage",
            "dependencies": [],
            "details": "Créer ThemeService dans src/app/core/services/ avec signals pour gérer l'état du thème ('light' | 'dark'). Implémenter toggleTheme(), setTheme(), currentTheme signal en lecture seule. Persister la préférence dans localStorage avec la clé 'theme-preference'. Initialiser avec thème système ou valeur par défaut 'light'. Utiliser inject() et signal() d'Angular. Appliquer les classes CSS dynamiquement sur document.documentElement.",
            "status": "done",
            "testStrategy": "Tester le basculement de thème avec changement immédiat, vérifier la persistance localStorage, contrôler l'initialisation avec thème par défaut et système"
          },
          {
            "id": 2,
            "title": "Définir les variables CSS custom properties pour les thèmes",
            "description": "Créer les variables CSS globales pour les couleurs des thèmes sombre et clair dans styles.scss",
            "dependencies": [
              "11.1"
            ],
            "details": "Dans src/styles.scss, définir les custom properties CSS pour les deux thèmes. Variables pour couleurs primaires, secondaires, backgrounds (principal, secondaire, surfaces), textes (primaire, secondaire, tertiaire), bordures, ombres. Utiliser la structure :root { } pour le thème clair et [data-theme='dark'] { } pour le thème sombre. Couleurs cohérentes et accessibles avec contraste WCAG AA minimum. Prévoir variables pour états hover, focus, active.",
            "status": "done",
            "testStrategy": "Vérifier que les variables CSS sont correctement appliquées selon le thème, contrôler les contrastes d'accessibilité, tester les états interactifs"
          },
          {
            "id": 3,
            "title": "Créer le composant ThemeToggleComponent",
            "description": "Développer le composant bouton pour basculer entre les modes sombre et clair",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Créer ThemeToggleComponent dans src/app/shared/ui/theme-toggle/ avec structure organisée (index.ts, .component.ts, .html, .scss). Utiliser ThemeService avec inject(). Template avec bouton et icônes pour soleil/lune. Accessibilité avec aria-label, aria-pressed. Animations CSS smooth pour transition d'icônes. Styles avec variables CSS custom properties. Signal computed pour afficher l'icône selon thème actuel.",
            "status": "done",
            "testStrategy": "Tester le changement visuel d'icône selon le thème, vérifier l'accessibilité (aria-*, navigation clavier), valider les animations de transition"
          },
          {
            "id": 4,
            "title": "Créer le composant HeaderComponent avec titre et toggle thème",
            "description": "Développer le composant header contenant le titre de l'application et le toggle de thème",
            "dependencies": [
              "11.3"
            ],
            "details": "Créer HeaderComponent dans src/app/layout/ui/header/ avec structure organisée. Template avec titre 'YouTube Looper' et ThemeToggleComponent. Utiliser flexbox pour alignement horizontal (titre à gauche, toggle à droite). Header fixe en position sticky ou fixed selon besoins. Responsive avec ajustements mobile. Sémantique HTML correcte avec balises header, h1. Styles avec variables CSS custom properties.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage correct du titre et du toggle, tester la responsivité mobile/desktop, valider la position fixe et l'accessibilité"
          },
          {
            "id": 5,
            "title": "Créer le composant MainLayoutComponent avec structure grid",
            "description": "Développer le layout principal avec header, zone contenu principal et footer en CSS Grid",
            "dependencies": [
              "11.4"
            ],
            "details": "Créer MainLayoutComponent dans src/app/layout/ui/main-layout/ avec structure HTML sémantique (header, main, footer). Utiliser CSS Grid pour layout responsive : header fixe en haut, main flexible au centre, footer en bas. Grid-template-rows avec fr unités. Zone main avec padding et préparation pour futurs composants. Footer discret avec copyright et liens essentiels. Intégrer HeaderComponent. Responsive avec ajustements mobile/tablet.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage correct des trois zones (header, main, footer), tester la responsivité sur mobile/desktop, contrôler que la zone main occupe l'espace disponible"
          },
          {
            "id": 6,
            "title": "Créer le service ThemeService pour la gestion du mode sombre/clair",
            "description": "Développer un service Angular utilisant des signals pour gérer l'état du thème (dark/light) et persister les préférences utilisateur dans localStorage",
            "dependencies": [],
            "details": "Créer ThemeService dans src/app/core/services/ avec signal pour currentTheme ('light' | 'dark'). Implémenter méthodes toggleTheme(), setTheme(), loadTheme() depuis localStorage. Utiliser effect() pour appliquer la classe CSS sur document.body. Initialiser avec la préférence système via window.matchMedia('(prefers-color-scheme: dark)'). Persister automatiquement les changements dans localStorage avec clé 'youtube-looper-theme'.",
            "status": "done",
            "testStrategy": "Tester l'initialisation avec préférence système, vérifier la persistance localStorage, valider l'application des classes CSS sur body"
          },
          {
            "id": 7,
            "title": "Définir les variables CSS et thèmes dans styles.scss",
            "description": "Créer un système de variables CSS custom properties pour supporter les thèmes dark et light avec toutes les couleurs nécessaires",
            "dependencies": [
              "11.6"
            ],
            "details": "Dans src/styles.scss, définir :root avec variables CSS --color-primary, --color-secondary, --color-background, --color-surface, --color-text-primary, --color-text-secondary, --color-border, --color-accent pour le thème light. Créer .dark-theme avec les mêmes variables mais valeurs adaptées au mode sombre. Ajouter reset CSS basique et styles globaux. Utiliser des couleurs accessibles avec contraste suffisant (minimum WCAG AA). Prévoir variables pour les transitions et shadows.",
            "status": "done",
            "testStrategy": "Vérifier que les variables CSS sont bien définies, tester l'application des thèmes en basculant les classes, valider les contrastes d'accessibilité"
          },
          {
            "id": 8,
            "title": "Créer le composant ThemeToggleComponent",
            "description": "Développer un composant toggle switch pour basculer entre les modes sombre et clair avec feedback visuel immédiat",
            "dependencies": [
              "11.6",
              "11.7"
            ],
            "details": "Créer ThemeToggleComponent dans src/app/shared/ui/theme-toggle/ avec template HTML contenant un bouton toggle stylisé. Utiliser inject(ThemeService) pour accéder au service. Implémenter onClick() qui appelle themeService.toggleTheme(). Afficher une icône soleil/lune selon le thème actuel avec computed() signal. Styles SCSS pour switch animé avec transition smooth. Accessible avec rôles ARIA appropriés et support clavier (space/enter).",
            "status": "done",
            "testStrategy": "Tester le basculement visuel immédiat, vérifier l'accessibilité clavier, valider les animations CSS de transition"
          },
          {
            "id": 9,
            "title": "Créer le composant HeaderComponent avec titre et toggle thème",
            "description": "Développer le composant header contenant le titre de l'application et le toggle de thème, avec layout responsive",
            "dependencies": [
              "11.8"
            ],
            "details": "Créer HeaderComponent dans src/app/shared/ui/header/ avec template contenant <header> sémantique. Structure : titre 'YouTube Looper' à gauche, ThemeToggleComponent à droite. Utiliser flexbox pour alignement avec justify-content: space-between. Header fixe en haut (position: fixed, top: 0) avec z-index approprié. Styles responsive : titre plus petit sur mobile, padding adaptatif. Hauteur fixe (ex: 60px) pour que le main content puisse s'adapter.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage titre/toggle, tester la responsivité mobile/desktop, valider la position fixe et l'alignement"
          },
          {
            "id": 10,
            "title": "Créer le MainLayoutComponent avec structure Grid responsive",
            "description": "Développer le composant layout principal utilisant CSS Grid pour organiser header, main et footer de façon responsive",
            "dependencies": [
              "11.9"
            ],
            "details": "Créer MainLayoutComponent dans src/app/core/layout/ avec template contenant HeaderComponent, <main> avec router-outlet, et <footer> minimaliste. Utiliser CSS Grid : grid-template-rows: auto 1fr auto pour header/main/footer. Header fixe compensé par padding-top sur main. Main zone flexible pour contenu futur. Footer discret avec liens copyright et version. Responsive : adapter grid sur mobile. Classes CSS utilisant les variables de thème définies. Intégrer ng-content ou router-outlet selon besoins.",
            "status": "done",
            "testStrategy": "Vérifier la structure Grid responsive, tester l'affichage des trois zones, valider l'adaptation mobile et l'application des thèmes"
          }
        ]
      },
      {
        "id": 12,
        "title": "Interface utilisateur principale intégrée avec layout responsive",
        "description": "Créer l'interface utilisateur définitive en intégrant UrlInputComponent et VideoPlayerComponent dans un layout responsive cohérent avec zones préparées pour les futurs composants.",
        "details": "Créer AppMainComponent qui remplace le composant de test actuel en intégrant UrlInputComponent et VideoPlayerComponent existants. Implémenter un design system modulaire avec CSS Grid pour organiser les zones : zone de saisie URL en haut, zone player principale au centre, zone contrôles vide préparée pour les futurs composants (timeline, boucles, vitesse), et footer discret. Utiliser CSS custom properties pour maintenir la cohérence avec le thème dark/light existant. Implémenter une architecture responsive mobile-first avec breakpoints : mobile (<768px), tablet (768px-1024px), desktop (>1024px). Créer des container classes réutilisables (.container, .player-zone, .controls-zone) pour standardiser les espacements et marges. Préparer les emplacements avec des div conteneurs commentés et des classes CSS prêtes pour l'intégration future des composants timeline, loop-controls, et speed-control. Optimiser la hiérarchie visuelle avec une mise en page centrée sur la vidéo comme élément principal. Assurer la compatibilité avec les composants existants sans modification de leur API.",
        "testStrategy": "Vérifier l'intégration correcte des composants UrlInputComponent et VideoPlayerComponent, tester la responsivité sur tous les breakpoints (mobile, tablet, desktop), valider l'affichage cohérent du thème dark/light, contrôler que les zones préparées sont correctement positionnées et dimensionnées, tester la navigation entre saisie URL et lecture vidéo, vérifier que le layout s'adapte aux différentes orientations d'écran, valider l'accessibilité avec navigation clavier, tester sur différents navigateurs (Chrome, Firefox, Safari, Edge).",
        "status": "done",
        "dependencies": [
          11
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le composant AppMainComponent avec architecture modulaire",
            "description": "Créer AppMainComponent dans src/app/features/main-app/ avec structure modulaire selon les conventions du projet, incluant les zones d'interface définies (saisie URL, player, contrôles futurs) et l'intégration des composants existants.",
            "dependencies": [],
            "details": "Générer le composant AppMainComponent avec ng generate dans src/app/features/main-app/ui/app-main/. Définir la structure HTML avec CSS Grid pour organiser les zones : .url-input-zone (en haut), .player-zone (centre), .controls-zone (vide pour futurs composants), .footer-zone (discret). Créer les fichiers index.ts selon la convention du projet. Importer et intégrer UrlInputComponent et VideoPlayerComponent existants. Créer les barrel exports nécessaires dans src/app/features/main-app/index.ts.",
            "status": "done",
            "testStrategy": "Vérifier la génération correcte du composant, la structure HTML avec CSS Grid, l'intégration des composants existants UrlInputComponent et VideoPlayerComponent, et la création des fichiers index.ts avec barrel exports."
          },
          {
            "id": 2,
            "title": "Implémenter le système de design modulaire avec CSS Grid et custom properties",
            "description": "Créer le système CSS Grid responsive avec zones bien définies et utiliser les custom properties existantes pour maintenir la cohérence avec le thème dark/light.",
            "dependencies": [
              "12.1"
            ],
            "details": "Dans app-main.component.scss, implémenter CSS Grid avec grid-template-areas pour définir les zones (url-input, player, controls, footer). Utiliser les variables CSS existantes du fichier styles.scss (--spacing-*, --background-*, --border-*). Créer des classes container réutilisables (.container, .player-zone, .controls-zone) avec espacements standardisés. Assurer la compatibilité avec le système de thème existant (dark/light).",
            "status": "done",
            "testStrategy": "Vérifier la mise en page avec CSS Grid, l'utilisation correcte des custom properties existantes, l'affichage cohérent en mode dark et light, et la réutilisabilité des classes container."
          },
          {
            "id": 3,
            "title": "Implémenter l'architecture responsive mobile-first avec breakpoints",
            "description": "Créer le design responsive avec breakpoints mobile (<768px), tablet (768px-1024px), desktop (>1024px) et optimiser la hiérarchie visuelle centrée sur la vidéo.",
            "dependencies": [
              "12.2"
            ],
            "details": "Définir les breakpoints dans app-main.component.scss : mobile (<768px), tablet (768px-1024px), desktop (>1024px). Adapter la grille CSS Grid pour chaque breakpoint (colonne unique mobile, grille adaptée tablet/desktop). Optimiser les tailles et espacements pour chaque format. Centrer la vidéo comme élément principal de l'interface. Gérer les orientations portrait/paysage sur tablette.",
            "status": "done",
            "testStrategy": "Tester l'affichage sur différentes tailles d'écran (mobile, tablet, desktop), vérifier la réorganisation de la grille selon les breakpoints, valider le centrage de la vidéo et l'optimisation des espaces."
          },
          {
            "id": 4,
            "title": "Préparer les zones pour les futurs composants avec containers commentés",
            "description": "Créer les emplacements prêts pour l'intégration future des composants timeline, loop-controls et speed-control avec des conteneurs commentés et classes CSS préparées.",
            "dependencies": [
              "12.3"
            ],
            "details": "Dans le template app-main.component.html, ajouter des div conteneurs commentés dans la .controls-zone pour timeline-component, loop-controls-component, et speed-control-component. Créer les classes CSS correspondantes (.timeline-container, .loop-controls-container, .speed-controls-container) avec dimensionnement et positionnement préparés. Ajouter des commentaires explicatifs dans le code pour l'intégration future. Préparer l'API d'intégration avec des propriétés/méthodes placeholder commentées.",
            "status": "done",
            "testStrategy": "Vérifier la présence des conteneurs commentés dans le HTML, les classes CSS préparées avec dimensions appropriées, la structure prête pour l'intégration future sans impact sur l'affichage actuel."
          },
          {
            "id": 5,
            "title": "Remplacer TestYouTubeComponent par AppMainComponent dans MainLayoutComponent",
            "description": "Modifier MainLayoutComponent pour utiliser AppMainComponent à la place de TestYouTubeComponent et assurer la compatibilité avec l'architecture existante.",
            "dependencies": [
              "12.1",
              "12.2",
              "12.3",
              "12.4"
            ],
            "details": "Dans main-layout.component.ts, remplacer l'import TestYouTubeComponent par AppMainComponent. Mettre à jour le tableau imports et le template main-layout.component.html pour utiliser <app-main></app-main> à la place de <app-test-youtube></app-test-youtube>. Vérifier que l'intégration respecte la structure existante du layout et les styles CSS. Préserver la fonctionnalité du header avec theme toggle et footer.",
            "status": "done",
            "testStrategy": "Vérifier le remplacement correct dans main-layout.component.ts et le template, s'assurer que l'application fonctionne sans erreur avec le nouveau composant, valider que le header et footer restent fonctionnels, et tester l'intégration des composants UrlInputComponent et VideoPlayerComponent."
          }
        ]
      },
      {
        "id": 13,
        "title": "Connecter la timeline interactive avec le service de boucles pour une lecture automatique",
        "description": "Implémenter la liaison entre TimelineComponent et LoopService pour que les changements des poignées draggables mettent automatiquement à jour les bornes de boucle et activent la surveillance de boucle en temps réel avec contrôle automatique de la position de lecture.",
        "status": "done",
        "dependencies": [
          12
        ],
        "priority": "medium",
        "details": "Intégrer TimelineComponent avec LoopService en créant une communication bidirectionnelle via Angular Signals. Implémenter l'écoute des événements drag des poignées start/end pour mettre à jour automatiquement les bornes via loopService.setLoopBounds(). Activer automatiquement loop.isActive = true dès qu'une borne est modifiée. NOUVEAU : Lors du drag de la poignée start, positionner automatiquement la lecture vidéo sur cette position via YouTubePlayerService.seekTo(). Lors du déclenchement de play, démarrer la lecture depuis startTime et implémenter la boucle automatique entre start et end. Synchroniser l'affichage visual de la timeline avec l'état du LoopService. Implémenter la logique de validation des bornes (start < end, bornes dans les limites de la vidéo). Ajouter des debounce pour éviter les appels excessifs lors du drag. Gérer les cas edge : vidéo non chargée, bornes invalides, changement de vidéo. Utiliser computed() pour synchroniser l'état visual avec les données du service. Implémenter des animations CSS smooth pour les transitions des poignées.",
        "testStrategy": "Tester le drag des poignées start/end et vérifier que les bornes sont mises à jour dans LoopService, NOUVEAU : valider que le drag de la poignée start repositionne la lecture vidéo automatiquement, tester que le bouton play démarre la lecture depuis startTime défini, valider la boucle automatique entre start et end lors de la lecture, valider l'activation automatique de la boucle lors des changements, tester la synchronisation bidirectionnelle timeline ↔ service, vérifier la validation des bornes (start < end), tester le comportement avec vidéos de différentes durées, valider les cas edge (pas de vidéo, bornes invalides), tester les performances lors de drag intensif, vérifier l'affichage correct de la zone de boucle sur la timeline.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implémenter l'injection des services dans TimelineComponent",
            "description": "Intégrer LoopService et YouTubePlayerService dans TimelineComponent pour établir la communication bidirectionnelle",
            "dependencies": [],
            "details": "Injecter LoopService et YouTubePlayerService dans TimelineComponent via inject(). Créer des computed() signals pour synchroniser l'affichage des poignées avec loop.startTime et loop.endTime du service. Implémenter une méthode de validation des bornes qui vérifie que startTime < endTime et que les bornes sont dans la durée totale de la vidéo.",
            "status": "done",
            "testStrategy": "Vérifier que les services sont correctement injectés, tester que les computed signals reflètent les changements du LoopService, valider la logique de validation des bornes"
          },
          {
            "id": 2,
            "title": "Connecter les événements drag des poignées au LoopService",
            "description": "Implémenter la liaison entre les événements drag des poignées start/end et les méthodes de mise à jour du LoopService",
            "dependencies": [
              "13.1"
            ],
            "details": "Modifier les handlers d'événements drag pour appeler loopService.setLoopBounds(startTime, endTime) lors des changements. Implémenter un debounce de 100ms pour éviter les appels excessifs pendant le drag. Activer automatiquement loop.isActive = true dès qu'une borne est modifiée. Ajouter la validation des bornes avant la mise à jour du service.",
            "status": "done",
            "testStrategy": "Tester le drag des poignées et vérifier que LoopService est mis à jour, valider le debounce pendant le drag continu, confirmer que isActive devient true automatiquement"
          },
          {
            "id": 3,
            "title": "Implémenter le repositionnement automatique lors du drag de start",
            "description": "Ajouter la fonctionnalité de repositionnement automatique de la lecture vidéo lors du drag de la poignée start",
            "dependencies": [
              "13.2"
            ],
            "details": "Modifier le handler de drag de la poignée start pour appeler youTubePlayerService.seekTo() avec la nouvelle position. Implémenter une logique de debounce spécifique pour seekTo (200ms) pour éviter les appels trop fréquents à l'API YouTube. Gérer les cas où la vidéo n'est pas encore chargée ou en état de pause. Ajouter un feedback visuel pendant le repositionnement.",
            "status": "done",
            "testStrategy": "Valider que le drag de la poignée start repositionne automatiquement la lecture, tester le debounce pour éviter les appels excessifs à seekTo, vérifier le comportement avec une vidéo en pause"
          },
          {
            "id": 4,
            "title": "Synchroniser l'affichage visuel avec l'état du LoopService",
            "description": "Implémenter la synchronisation complète entre l'affichage visuel des poignées et l'état du LoopService",
            "dependencies": [
              "13.2"
            ],
            "details": "Utiliser computed() pour calculer les positions visuelles des poignées basées sur loop.startTime et loop.endTime. Implémenter la zone colorée dynamique entre les poignées basée sur l'état isActive. Ajouter des animations CSS smooth pour les transitions des poignées lors des changements programmatiques. Gérer l'affichage des temps au-dessus des poignées avec formatage approprié (MM:SS).",
            "status": "done",
            "testStrategy": "Vérifier que les poignées se déplacent automatiquement lors des changements dans LoopService, tester l'affichage de la zone colorée, valider les animations smooth des transitions"
          },
          {
            "id": 5,
            "title": "Gérer les cas edge et finaliser l'intégration",
            "description": "Implémenter la gestion des cas edge et finaliser l'intégration complète entre timeline et services",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "Gérer les cas où la vidéo n'est pas encore chargée (désactiver les interactions). Implémenter la réinitialisation des bornes lors du changement de vidéo. Ajouter la gestion d'erreur pour les appels à seekTo() qui échouent. Implémenter la logique de nettoyage des timers et subscriptions dans ngOnDestroy(). Ajouter des logs de debug pour faciliter le débogage en développement.",
            "status": "done",
            "testStrategy": "Tester avec une vidéo non chargée, valider le comportement lors du changement de vidéo, vérifier la gestion des erreurs seekTo(), confirmer le nettoyage des ressources"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-07T19:39:54.188Z",
      "updated": "2025-09-14T20:14:12.635Z",
      "description": "Tasks for master context"
    }
  },
  "audio-looper": {
    "tasks": [
      {
        "id": 1,
        "title": "Mise en place de la navigation entre modules YouTube Looper et Audio Looper",
        "description": "Créer un système de navigation (onglets ou boutons) permettant de basculer entre les modules YouTube Looper existant et le nouveau module Audio Looper",
        "details": "Implémenter un composant de navigation avec deux onglets/boutons: 'YouTube Looper' et 'Audio Looper'. Utiliser Angular Router pour la navigation entre les modules. Créer les routes appropriées dans app.routes.ts. Ajouter les styles SCSS pour les onglets avec état actif/inactif. Assurer une navigation fluide sans rechargement de page. Positionner la navigation en haut de l'application selon le mockup fourni.",
        "testStrategy": "Vérifier que les onglets sont visibles en haut de l'application, que le clic sur chaque onglet change la vue sans rechargement, que l'onglet actif est visuellement distinct, et que la navigation fonctionne sur mobile et desktop.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T07:05:42.042Z"
      },
      {
        "id": 2,
        "title": "Création de la structure de base du module Audio Looper",
        "description": "Créer l'architecture de base du module Audio Looper avec les composants principaux et la structure de dossiers recommandée",
        "details": "Créer la structure de dossiers selon l'architecture Angular suggérée dans src/app/features/audio-looper/. Générer les composants principaux: audio-looper-container, file-upload, audio-player, loop-controls, pitch-control, speed-control, volume-control. Chaque composant doit avoir son propre dossier avec fichiers .ts, .html, .scss et index.ts. Implémenter les barrel exports dans tous les index.ts. Créer les services de base: audio-player.service.ts, tone-engine.service.ts, waveform.service.ts. Utiliser strictement les standalone components Angular 19.2.",
        "testStrategy": "Vérifier que tous les composants sont générés correctement, que la structure de dossiers respecte les conventions, que les imports via barrel exports fonctionnent, et que l'application compile sans erreur avec ng build.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T09:43:29.007Z"
      },
      {
        "id": 3,
        "title": "Installation et configuration de Tone.js",
        "description": "Installer Tone.js et configurer l'environnement audio pour le traitement des fichiers audio",
        "details": "Installer les dépendances: npm install tone et npm install --save-dev @types/tone. Créer le service tone-engine.service.ts avec les méthodes de base pour initialiser le contexte audio Tone.js. Implémenter les méthodes pour charger un fichier audio, contrôler la lecture (play/pause), et gérer le volume. Configurer le service comme singleton avec inject() selon les conventions Angular. Ajouter la gestion d'erreurs pour les cas où l'audio n'est pas supporté par le navigateur.",
        "testStrategy": "Vérifier que Tone.js est correctement installé, que le service s'initialise sans erreur, que le contexte audio se démarre correctement (gestion des politiques autoplay), et qu'un fichier audio basique peut être chargé via Tone.Player.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T10:08:02.189Z"
      },
      {
        "id": 4,
        "title": "Implémentation du composant d'upload centré en mode vide",
        "description": "Créer le composant file-upload avec zone drag & drop centrée et validation des fichiers audio",
        "details": "Implémenter le composant file-upload avec zone de drag & drop et bouton 'Parcourir'. Centrer verticalement et horizontalement la zone d'upload quand aucun fichier n'est chargé (selon mockup). Valider les formats supportés: MP3, WAV, OGG, M4A. Limiter la taille à 10 Mo (10 485 760 octets). Afficher des messages d'erreur clairs pour formats non supportés ou fichiers trop volumineux. Utiliser les directives Angular pour le drag & drop (dragover, dragleave, drop). Implémenter les styles SCSS responsive pour mobile/desktop avec zone tactile suffisante.",
        "testStrategy": "Tester le drag & drop de fichiers valides et invalides, vérifier les messages d'erreur, confirmer la limitation de taille, valider le centrage sur différentes tailles d'écran, et s'assurer que l'upload fonctionne sur mobile et desktop.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T10:43:12.111Z"
      },
      {
        "id": 5,
        "title": "Création du composant waveform-display pour visualisation de l'onde audio",
        "description": "Développer le composant central de visualisation de la forme d'onde audio avec Canvas API",
        "details": "Créer le composant waveform-display comme élément graphique principal. Utiliser Canvas API ou wavesurfer.js pour générer et afficher la forme d'onde. Implémenter la méthode de génération de waveform à partir d'un fichier audio chargé via Tone.js. Dimensionner le canvas pour être responsive et touch-friendly (minimum 48px de hauteur sur mobile). Créer le service waveform.service.ts pour la logique de génération et de rendu. Optimiser les performances pour des fichiers jusqu'à 10 MB. Ajouter un loader pendant la génération de la waveform (moins d'1 seconde requis).",
        "testStrategy": "Vérifier que la waveform s'affiche correctement après upload d'un fichier audio, que la génération prend moins d'1 seconde, que le canvas est responsive sur tous les écrans, et que la visualisation est claire et lisible.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T11:27:55.525Z"
      },
      {
        "id": 6,
        "title": "Implémentation de la révélation progressive de l'interface",
        "description": "Créer le système de transition fluide entre l'état vide (upload centré) et l'état chargé (waveform + contrôles)",
        "details": "Implémenter la logique de révélation progressive dans audio-looper-container. En mode vide: afficher uniquement la zone d'upload centrée. Après chargement réussi: animation de transition pour faire apparaître la waveform au centre et les contrôles autour. Minimiser la zone d'upload vers le haut avec nom du fichier et bouton 'Change File'. Utiliser les animations CSS/Angular pour les transitions fluides. Gérer les états: vide, chargement, chargé, erreur. Appliquer les styles selon le mockup fourni avec layout adaptatif.",
        "testStrategy": "Vérifier les transitions fluides entre états, valider que l'upload se minimise correctement après chargement, confirmer que les contrôles apparaissent progressivement, et tester l'expérience utilisateur complète sur mobile et desktop.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T13:43:01.161Z"
      },
      {
        "id": 7,
        "title": "Développement du lecteur audio de base avec curseur sur waveform",
        "description": "Implémenter les contrôles de lecture de base (play/pause) avec curseur de lecture animé sur la waveform",
        "details": "Créer le composant audio-player avec boutons Play/Pause. Implémenter l'affichage du temps courant et durée totale au format MM:SS. Développer le curseur de lecture comme ligne verticale se déplaçant sur la waveform en temps réel (60 FPS). Connecter le lecteur audio avec Tone.js Player. Synchroniser la position du curseur avec la position de lecture audio. Gérer les états play/pause avec feedback visuel immédiat. Optimiser les performances pour animation fluide du curseur.",
        "testStrategy": "Tester la lecture/pause, vérifier la synchronisation curseur-audio, valider l'affichage des temps, confirmer la fluidité de l'animation du curseur à 60 FPS, et s'assurer du bon fonctionnement sur mobile.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T14:08:42.553Z"
      },
      {
        "id": 8,
        "title": "Implémentation de la navigation directe sur la waveform",
        "description": "Permettre à l'utilisateur de cliquer sur la waveform pour se positionner à un instant précis",
        "details": "Ajouter la gestion des événements de clic sur le canvas de la waveform. Calculer la position temporelle en fonction de la position X du clic. Implémenter la méthode pour déplacer la lecture à la position cliquée via Tone.js. Optimiser pour le tactile mobile avec zone de touch suffisamment large. Ajouter un feedback visuel lors du clic (highlight temporaire). Gérer les cas limites (clic en dehors de la durée audio). Assurer une réactivité immédiate pour une expérience utilisateur fluide.",
        "testStrategy": "Tester les clics sur différentes parties de la waveform, vérifier la précision du positionnement temporel, valider l'interaction tactile sur mobile, et confirmer le feedback visuel lors des interactions.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T17:34:36.106Z"
      },
      {
        "id": 9,
        "title": "Création du système de boucle A/B avec marqueurs visuels",
        "description": "Implémenter les contrôles de boucle A/B avec marqueurs et zone colorée superposés sur la waveform",
        "details": "Développer le composant loop-controls avec boutons 'Set A', 'Set B', 'Loop ON/OFF', 'Reset Loop'. Implémenter les marqueurs visuels A et B comme lignes verticales colorées superposées sur la waveform. Créer la zone colorée entre A et B directement sur l'onde audio (overlay). Intégrer avec Tone.js pour la lecture en boucle automatique (setLoopPoints). Gérer les états de boucle active/inactive avec indicateur visuel 'Loop Active'. Assurer que la lecture saute automatiquement de B vers A pendant la boucle.",
        "testStrategy": "Tester la définition des points A et B, vérifier l'affichage des marqueurs sur la waveform, valider la zone colorée entre A et B, confirmer la lecture en boucle automatique, et tester le reset des points.",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le composant loop-controls avec boutons de base",
            "description": "Développer le composant Angular loop-controls avec les quatre boutons principaux: 'Set A', 'Set B', 'Loop ON/OFF', et 'Reset Loop'",
            "dependencies": [],
            "details": "Créer le composant loop-controls dans src/app/features/audio-looper/ui/loop-controls/ avec template HTML contenant les 4 boutons selon les conventions du projet (boutons textuels uniquement). Implémenter la logique de base pour les événements de clic. Définir les états internes pour les points A et B (null par défaut) et l'état de boucle active (false par défaut). Ajouter les styles SCSS pour l'apparence des boutons selon le design minimaliste du projet.",
            "status": "done",
            "testStrategy": "Vérifier que les 4 boutons s'affichent correctement, valider les événements de clic, confirmer les styles selon le design, et tester la responsivité sur mobile et desktop.",
            "updatedAt": "2025-10-19T21:02:18.939Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implémenter la logique de définition des points A et B",
            "description": "Développer la fonctionnalité pour capturer et stocker les positions temporelles des points A et B lors des clics sur 'Set A' et 'Set B'",
            "dependencies": [
              1
            ],
            "details": "Intégrer le service audio-player-service pour obtenir la position de lecture courante. Implémenter les méthodes setPointA() et setPointB() qui stockent la position temporelle actuelle. Ajouter la validation: point A doit être antérieur au point B. Gérer les cas d'erreur (aucun audio chargé, points invalides). Émettre des événements vers le composant parent pour synchroniser l'état avec la waveform. Implémenter la logique de reset qui remet les points à null.",
            "status": "done",
            "testStrategy": "Tester la définition des points A et B à différentes positions, valider la validation A < B, vérifier le comportement sans audio chargé, et confirmer le reset des points.",
            "parentId": "undefined",
            "updatedAt": "2025-10-19T21:05:19.916Z"
          },
          {
            "id": 3,
            "title": "Développer les marqueurs visuels A et B sur la waveform",
            "description": "Implémenter l'affichage des marqueurs A et B comme lignes verticales colorées superposées sur le canvas de la waveform",
            "dependencies": [
              2
            ],
            "details": "Modifier le composant waveform-display pour ajouter une couche de marqueurs au-dessus de l'onde audio. Implémenter la méthode drawMarkers() qui dessine des lignes verticales colorées aux positions des points A (rouge) et B (bleu). Calculer les positions X des marqueurs en fonction de la durée audio et des timestamps. Ajouter des labels 'A' et 'B' au-dessus des marqueurs. Gérer la mise à jour en temps réel des marqueurs lors des changements de points. Optimiser pour éviter les redraws inutiles.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage des marqueurs aux bonnes positions, valider les couleurs et labels, confirmer la mise à jour lors des changements de points, et tester la performance sur différents fichiers audio.",
            "parentId": "undefined",
            "updatedAt": "2025-10-19T21:06:34.530Z"
          },
          {
            "id": 4,
            "title": "Créer la zone colorée entre les points A et B",
            "description": "Implémenter l'overlay coloré qui met en évidence la zone de boucle entre les marqueurs A et B sur la waveform",
            "dependencies": [
              3
            ],
            "details": "Ajouter la méthode drawLoopZone() dans waveform-display qui dessine un rectangle semi-transparent entre les positions A et B. Utiliser une couleur d'overlay appropriée (ex: rgba(255, 255, 0, 0.2) pour jaune transparent). Calculer dynamiquement la largeur et position de la zone en fonction des points A et B. Gérer l'affichage conditionnel: zone visible uniquement si A et B sont définis. Assurer que la zone se met à jour lors des changements de points. Maintenir la performance en évitant les redraws excessifs.",
            "status": "done",
            "testStrategy": "Valider l'affichage de la zone colorée entre A et B, vérifier la transparence et la couleur, confirmer la mise à jour dynamique lors des changements de points, et tester que la zone disparaît lors du reset.",
            "parentId": "undefined",
            "updatedAt": "2025-10-19T21:07:41.414Z"
          },
          {
            "id": 5,
            "title": "Intégrer la lecture en boucle automatique avec Tone.js",
            "description": "Implémenter la logique de lecture en boucle utilisant Tone.js Player avec saut automatique de B vers A",
            "dependencies": [
              4
            ],
            "details": "Modifier le service audio-player-service pour supporter les boucles avec Tone.js Player.setLoopPoints(). Implémenter la méthode enableLoop() qui active la boucle entre les points A et B. Gérer l'événement de fin de segment pour faire sauter la lecture de B vers A automatiquement. Ajouter la logique toggleLoop() pour activer/désactiver la boucle depuis le bouton 'Loop ON/OFF'. Implémenter l'indicateur visuel 'Loop Active' dans l'interface. Synchroniser l'état de boucle avec les composants visuels. Gérer les cas d'erreur (points non définis, audio non chargé).",
            "status": "done",
            "testStrategy": "Tester l'activation/désactivation de la boucle, vérifier le saut automatique de B vers A, valider l'indicateur 'Loop Active', confirmer la synchronisation avec les marqueurs visuels, et tester avec différents segments de boucle.",
            "parentId": "undefined",
            "updatedAt": "2025-10-19T21:08:59.173Z"
          }
        ],
        "updatedAt": "2025-10-19T21:08:59.173Z"
      },
      {
        "id": 11,
        "title": "Développement du contrôle de vitesse avec presets et stepper",
        "description": "Créer le composant de contrôle de vitesse avec boutons presets (0.5x, 0.75x, 1.0x) et stepper précis (0.4x-2.0x)",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "details": "Implémenter le composant speed-control avec boutons presets rapides: 0.5x, 0.75x, 1.0x. Développer le stepper [- | valeur | +] pour ajustements précis de 0.4x à 2.0x par incréments de 0.1x. Synchroniser les presets avec le stepper (clic preset met à jour le stepper). Utiliser Tone.js pour modifier la vitesse sans altérer la tonalité. Afficher la vitesse courante (ex. '0.6x', '1.2x'). Appliquer les changements en temps réel. Définir 1.0x comme vitesse par défaut au chargement.",
        "testStrategy": "Tester les boutons presets, valider le stepper sur toute la plage 0.4x-2.0x, vérifier la synchronisation preset-stepper, confirmer que la tonalité n'est pas altérée, et tester l'application en temps réel.",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer l'interface et les signaux du composant speed-control",
            "description": "Implémenter la logique de base du composant avec signals pour gérer l'état de vitesse",
            "dependencies": [],
            "details": "Créer les signals speedValue, showAdvanced et implémenter les méthodes de base (setSpeed, setSpeedCustom, toggleAdvanced). Injecter ToneEngineService pour la communication avec le moteur audio. Définir les presets rapides (0.5x, 0.75x, 1.0x) et la plage du stepper (0.4x-2.0x avec incréments de 0.1x). Initialiser la vitesse par défaut à 1.0x.",
            "status": "done",
            "testStrategy": "Vérifier que les signals sont initialisés correctement, que la vitesse par défaut est 1.0x, et que l'injection du ToneEngineService fonctionne",
            "updatedAt": "2025-10-20T05:38:35.923Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Développer le template HTML avec boutons presets et stepper",
            "description": "Créer l'interface utilisateur avec boutons presets et contrôle stepper [- | valeur | +]",
            "dependencies": [
              1
            ],
            "details": "Implémenter les trois boutons presets (0.5x, 0.75x, 1.0x) avec état actif visuel. Créer le stepper avec bouton moins, affichage de la valeur courante (ex: '0.6x', '1.2x'), et bouton plus. Ajouter un bouton 'Options' pour révéler/masquer les contrôles avancés. Assurer l'accessibilité avec aria-labels appropriés et navigation clavier.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage des boutons presets, du stepper et du bouton options, valider l'état actif visuel, et tester l'accessibilité clavier",
            "parentId": "undefined",
            "updatedAt": "2025-10-20T05:38:43.663Z"
          },
          {
            "id": 3,
            "title": "Implémenter la logique des boutons presets avec synchronisation stepper",
            "description": "Connecter les boutons presets pour qu'ils mettent à jour le stepper et appliquent la vitesse",
            "dependencies": [
              2
            ],
            "details": "Implémenter les gestionnaires de clic pour les boutons 0.5x, 0.75x, 1.0x qui mettent à jour le signal speedValue et appellent ToneEngineService.setPlaybackRate(). Synchroniser les presets avec le stepper pour que le clic sur un preset mette à jour l'affichage du stepper. Gérer l'état actif des boutons presets selon la vitesse courante.",
            "status": "done",
            "testStrategy": "Tester que chaque bouton preset applique la bonne vitesse, que le stepper se synchronise avec les presets, et que l'état visuel actif fonctionne correctement",
            "parentId": "undefined",
            "updatedAt": "2025-10-20T05:38:47.937Z"
          },
          {
            "id": 4,
            "title": "Développer la logique du stepper avec incréments précis",
            "description": "Implémenter les boutons + et - du stepper pour ajustements fins de vitesse",
            "dependencies": [
              3
            ],
            "details": "Créer les méthodes incrementSpeed() et decrementSpeed() avec incréments de 0.1x. Limiter la plage entre 0.4x et 2.0x. Implémenter la validation des bornes et l'arrondi pour éviter les erreurs de précision JavaScript. Mettre à jour le signal speedValue et appliquer via ToneEngineService.setPlaybackRate() en temps réel.",
            "status": "done",
            "testStrategy": "Valider la plage 0.4x-2.0x, tester les incréments de 0.1x, vérifier les bornes min/max, et confirmer l'application en temps réel de la vitesse",
            "parentId": "undefined",
            "updatedAt": "2025-10-20T05:38:50.920Z"
          },
          {
            "id": 5,
            "title": "Styliser le composant et finaliser l'intégration avec ToneEngine",
            "description": "Appliquer les styles SCSS et assurer l'intégration complète avec le moteur audio",
            "dependencies": [
              4
            ],
            "details": "Créer les styles SCSS pour les boutons presets avec état actif, le stepper avec design cohérent, et l'affichage de la vitesse courante. Implémenter l'abonnement au signal playbackRate de ToneEngineService pour synchronisation bidirectionnelle. Ajouter la gestion des états désactivés quand aucun fichier audio n'est chargé. Optimiser pour mobile avec boutons tactiles appropriés.",
            "status": "done",
            "testStrategy": "Vérifier l'apparence visuelle sur desktop et mobile, tester la synchronisation bidirectionnelle avec ToneEngine, et valider les états désactivés sans fichier audio",
            "parentId": "undefined",
            "updatedAt": "2025-10-20T05:38:53.934Z"
          }
        ],
        "updatedAt": "2025-10-20T05:38:53.934Z"
      },
      {
        "id": 12,
        "title": "Implémentation du contrôle de volume avec slider et mute",
        "description": "Créer le composant de contrôle du volume avec slider 0-100% et bouton mute/unmute",
        "details": "Développer le composant volume-control avec slider de volume (0% à 100%). Implémenter le bouton mute/unmute avec icônes 🔊/🔇 (seul composant avec icônes selon les spécifications). Intégrer avec Tone.Volume ou player.volume.value dans tone-engine.service. Gérer les états muet/actif avec changement d'icône. Appliquer les changements de volume en temps réel. Mémoriser le niveau de volume avant mute pour restauration. Utiliser les styles SCSS cohérents avec l'application.",
        "testStrategy": "Tester le slider de volume sur toute la plage 0-100%, vérifier le fonctionnement mute/unmute, valider les changements d'icônes, confirmer l'application en temps réel, et tester la mémorisation du volume avant mute.",
        "priority": "medium",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-22T05:30:48.694Z"
      },
      {
        "id": 13,
        "title": "Optimisation responsive et interactions tactiles",
        "description": "Optimiser l'interface pour mobile et tablette avec interactions tactiles améliorées",
        "details": "Adapter tous les composants pour responsive design (desktop 1920×1080 à 1280×720, tablet 768×1024, mobile 375×667 à 414×896). Optimiser la waveform pour interaction tactile avec zone minimum 48px de hauteur. Améliorer les contrôles pour usage tactile (taille des boutons, espacement). Tester en mode portrait et paysage. Assurer que l'onde audio reste le composant central sur toutes les tailles d'écran. Ajuster les styles SCSS avec breakpoints appropriés. Optimiser les performances sur appareils mobiles.",
        "testStrategy": "Tester sur différentes tailles d'écran (desktop, tablet, mobile), valider les interactions tactiles, vérifier le comportement en portrait/paysage, confirmer la lisibilité et ergonomie sur mobile, et tester les performances sur appareils mobiles.",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Finalisation des styles et cohérence visuelle",
        "description": "Finaliser les styles SCSS pour assurer la cohérence avec le module YouTube Looper et le design épuré",
        "details": "Harmoniser tous les styles SCSS avec ceux du module YouTube Looper existant. Appliquer le design minimaliste et épuré selon les spécifications. Implémenter les boutons textuels uniquement (sauf volume). Finaliser les états visuels (erreur, chargement, actif, inactif) pour qu'ils soient clairs. Optimiser la hiérarchie visuelle avec l'onde audio comme élément central. Ajuster les couleurs, typographie, espacement selon la charte graphique. Valider l'accessibilité et les contrastes.",
        "testStrategy": "Comparer visuellement avec le module YouTube Looper, vérifier la cohérence des styles, valider le design minimaliste, tester tous les états visuels, et confirmer la lisibilité sur différents écrans.",
        "priority": "low",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Tests manuels complets et optimisations finales",
        "description": "Effectuer les tests manuels complets de toutes les fonctionnalités et optimiser les performances",
        "details": "Effectuer des tests exhaustifs de tous les critères d'acceptation. Tester avec différents formats de fichiers audio (MP3, WAV, OGG, M4A). Valider les performances: chargement <2s pour 10MB, génération waveform <1s, effets temps réel sans latence, animation curseur 60 FPS. Vérifier la gestion d'erreurs avec fichiers corrompus ou non supportés. Tester la lecture en boucle fluide sans coupures. Optimiser le code pour les performances finales. Corriger les bugs identifiés lors des tests.",
        "testStrategy": "Effectuer une checklist complète des critères d'acceptation, mesurer les performances avec chronomètre, tester avec fichiers de différentes tailles et formats, valider tous les cas d'erreur, et confirmer que toutes les fonctionnalités répondent aux spécifications.",
        "priority": "high",
        "dependencies": [
          "14"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-22T05:30:48.695Z",
      "taskCount": 14,
      "completedCount": 11,
      "tags": [
        "audio-looper"
      ],
      "created": "2025-10-23T20:22:25.066Z",
      "description": "Tasks for audio-looper context",
      "updated": "2025-10-23T20:22:25.066Z"
    }
  },
  "rubberband-wasm-pitch": {
    "tasks": [
      {
        "id": 1,
        "title": "Préparation des assets statiques rubberband-wasm",
        "description": "Copier les fichiers rubberband.wasm et rubberband.umd.min.js dans public/assets/rubberband/ et vérifier leur accessibilité après build",
        "details": "Créer le dossier public/assets/rubberband/ et y copier les fichiers depuis .ai/rubberband-wasm/: rubberband.wasm (265 KB) et rubberband.umd.min.js (6.7 KB). Vérifier dans angular.json que les assets sont correctement configurés pour être copiés vers dist/assets/rubberband/. Tester l'accessibilité des fichiers après ng build en vérifiant qu'ils sont présents dans dist/assets/rubberband/.",
        "testStrategy": "Lancer ng build et vérifier que les fichiers rubberband.wasm et rubberband.umd.min.js sont présents dans dist/assets/rubberband/. Accéder aux URLs /assets/rubberband/rubberband.wasm et /assets/rubberband/rubberband.umd.min.js via le serveur de développement.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-17T17:02:30.535Z"
      },
      {
        "id": 2,
        "title": "Création des interfaces TypeScript pour le Web Worker",
        "description": "Créer les types TypeScript pour les messages d'entrée et de sortie du Web Worker rubberband",
        "details": "Créer le fichier src/app/features/audio-looper/services/workers/rubberband-worker.types.ts avec les interfaces RubberbandWorkerInput (channelBuffers: Float32Array[], sampleRate: number, pitch: number, tempo: number) et RubberbandWorkerOutput (channelBuffers?: Float32Array[], ready?: boolean, status?: string, progress?: number, error?: string). Créer aussi le fichier index.ts pour exporter les types.",
        "testStrategy": "Vérifier que les types sont correctement exportés et importables. Compiler le projet avec ng build pour s'assurer qu'il n'y a pas d'erreurs TypeScript.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-17T17:09:54.329Z"
      },
      {
        "id": 3,
        "title": "Implémentation du Web Worker rubberband",
        "description": "Créer le Web Worker qui charge rubberband-wasm et traite l'audio avec les phases Study et Process",
        "details": "Créer src/app/features/audio-looper/services/workers/rubberband.worker.ts. Implémenter le chargement asynchrone de rubberband-wasm via importScripts, l'initialisation du module avec locateFile pointant vers /assets/rubberband/. Implémenter le traitement audio avec phase Study (0-50%) et phase Process (50-100%), throttling des messages de progression (250ms), et gestion des erreurs. Utiliser la logique inspirée de .ai/rubberband-wasm/worker.js.",
        "testStrategy": "Tester le Worker isolément en envoyant un message de test et vérifier qu'il charge rubberband-wasm correctement (message ready: true). Tester le traitement d'un buffer audio simple avec des console.logs pour vérifier les phases Study et Process.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure du fichier Web Worker rubberband",
            "description": "Créer le fichier rubberband.worker.ts avec la structure de base et les interfaces TypeScript",
            "dependencies": [],
            "details": "Créer src/app/features/audio-looper/services/workers/rubberband.worker.ts avec les interfaces pour les messages entrants et sortants (RubberbandWorkerMessage, RubberbandWorkerResponse). Définir les types pour les commandes (LOAD, PROCESS) et les réponses (READY, PROGRESS, COMPLETE, ERROR). Implémenter la structure de base du Worker avec addEventListener('message') et la fonction postMessage.",
            "status": "done",
            "testStrategy": "Vérifier que le fichier TypeScript compile sans erreur et que la structure de base du Worker est correctement définie.",
            "updatedAt": "2025-10-17T17:34:15.950Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implémenter le chargement asynchrone de rubberband-wasm",
            "description": "Ajouter la logique de chargement du module WebAssembly avec importScripts et initialisation",
            "dependencies": [
              1
            ],
            "details": "Implémenter la fonction loadRubberbandModule() qui utilise importScripts pour charger rubberband-wasm depuis /assets/rubberband/. Configurer le module avec locateFile pointant vers le bon répertoire des assets. Gérer les erreurs de chargement et envoyer un message READY au thread principal une fois l'initialisation terminée. S'inspirer de la logique dans .ai/rubberband-wasm/worker.js.",
            "status": "done",
            "testStrategy": "Tester le Worker en envoyant un message de test et vérifier qu'il répond avec ready: true après avoir chargé rubberband-wasm correctement.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T17:34:19.282Z"
          },
          {
            "id": 3,
            "title": "Implémenter la phase Study du traitement audio",
            "description": "Créer la logique de la phase Study qui analyse l'audio avant le traitement (0-50% du progrès)",
            "dependencies": [
              2
            ],
            "details": "Implémenter la fonction processStudyPhase() qui utilise l'API rubberband pour analyser le buffer audio. Configurer les paramètres pitch et tempo reçus dans le message. Implémenter les callbacks de progression pour la phase Study (0% à 50%). Utiliser un throttling de 250ms pour les messages de progression. Gérer les erreurs spécifiques à cette phase et les communiquer au thread principal.",
            "status": "done",
            "testStrategy": "Tester avec un buffer audio simple et vérifier que les messages de progression sont envoyés correctement entre 0% et 50%. Vérifier les console.logs pour s'assurer que la phase Study s'exécute.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T17:34:22.379Z"
          },
          {
            "id": 4,
            "title": "Implémenter la phase Process du traitement audio",
            "description": "Créer la logique de la phase Process qui génère l'audio traité (50-100% du progrès)",
            "dependencies": [
              3
            ],
            "details": "Implémenter la fonction processProcessPhase() qui génère le buffer audio final avec les modifications de pitch et tempo. Continuer les callbacks de progression pour la phase Process (50% à 100%). Récupérer le buffer audio traité et l'envoyer au thread principal via un message COMPLETE. Implémenter la gestion mémoire pour libérer les ressources utilisées par rubberband après traitement.",
            "status": "done",
            "testStrategy": "Tester le traitement complet d'un buffer audio et vérifier que le buffer final est retourné. Vérifier que les messages de progression vont bien de 50% à 100% et que la phase Process s'exécute correctement.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T17:34:25.457Z"
          },
          {
            "id": 5,
            "title": "Implémenter la gestion des erreurs et l'orchestration générale",
            "description": "Ajouter la gestion complète des erreurs et coordonner les phases Study et Process",
            "dependencies": [
              4
            ],
            "details": "Implémenter la fonction principale processAudio() qui orchestre les phases Study et Process en séquence. Ajouter la gestion globale des erreurs avec try-catch et messages ERROR appropriés. Implémenter le throttling des messages de progression à 250ms maximum. Ajouter la validation des paramètres d'entrée (buffer, pitch, tempo) et la gestion des cas d'erreur. Nettoyer les ressources et gérer l'arrêt propre du Worker.",
            "status": "done",
            "testStrategy": "Tester les cas d'erreur (paramètres invalides, échec de chargement) et vérifier que les messages ERROR sont envoyés. Tester le traitement complet et s'assurer que toutes les ressources sont libérées correctement.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T17:34:28.603Z"
          }
        ],
        "updatedAt": "2025-10-17T17:34:28.603Z"
      },
      {
        "id": 4,
        "title": "Création du RubberbandEngineService",
        "description": "Créer le service Angular qui orchestre le traitement audio via le Web Worker avec cache et debounce",
        "details": "Créer src/app/features/audio-looper/services/rubberband-engine.service.ts avec injection Injectable providedIn: 'root'. Implémenter les signals pitch, playbackRate, isProcessing, processingProgress, processingStatus. Implémenter le cache Map<string, AudioBuffer> avec clés basées sur pitch et tempo. Implémenter le debounce 500ms pour éviter les traitements multiples. Créer l'API publique: loadOriginalBuffer(), setPitch(), setPlaybackRate(), getProcessedBuffer() Observable, clearCache().",
        "testStrategy": "Tester l'injection du service, la mise à jour des signals, le fonctionnement du cache (même paramètres = pas de retraitement), et le debounce en modifiant rapidement le pitch. Vérifier que getProcessedBuffer() émet correctement les buffers traités.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure de base du RubberbandEngineService",
            "description": "Créer le fichier src/app/features/audio-looper/services/rubberband-engine.service.ts avec la classe Injectable et les imports nécessaires",
            "dependencies": [],
            "details": "Créer le fichier rubberband-engine.service.ts avec le décorateur @Injectable({providedIn: 'root'}). Importer Injectable et signal depuis @angular/core, Observable et Subject depuis rxjs. Importer les types RubberbandWorkerInput et RubberbandWorkerOutput depuis workers/rubberband-worker.types. Définir la structure de base de la classe avec constructor vide.",
            "status": "done",
            "testStrategy": "Vérifier que le service peut être injecté dans un composant de test et que la structure de base compile sans erreur.",
            "updatedAt": "2025-10-17T20:15:44.823Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implémenter les signals d'état du service",
            "description": "Ajouter tous les signals requis pour l'état du service : pitch, playbackRate, isProcessing, processingProgress, processingStatus",
            "dependencies": [
              1
            ],
            "details": "Créer les signals readonly suivants : pitch = signal<number>(0) pour les demi-tons (-6 à +6), playbackRate = signal<number>(1.0) pour la vitesse (0.5x, 0.75x, 1.0x), isProcessing = signal<boolean>(false) pour l'état de traitement, processingProgress = signal<number>(0) pour le pourcentage (0-100), processingStatus = signal<string>('') pour le statut textuel du traitement.",
            "status": "done",
            "testStrategy": "Tester que tous les signals sont accessibles en lecture et que leurs valeurs par défaut sont correctes. Vérifier que les signals sont réactifs aux changements.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T20:17:30.673Z"
          },
          {
            "id": 3,
            "title": "Implémenter le système de cache avec Map",
            "description": "Créer le cache Map<string, AudioBuffer> avec la fonction getCacheKey basée sur pitch et tempo pour éviter les retraitements",
            "dependencies": [
              2
            ],
            "details": "Créer une propriété private audioCache = new Map<string, AudioBuffer>(). Implémenter la méthode privée getCacheKey(pitch: number, tempo: number): string qui retourne une clé unique basée sur la combinaison pitch-tempo (ex: 'p2_t0.75'). Implémenter clearCache(): void qui vide complètement le cache. Ajouter des méthodes privées hasCache() et getFromCache() pour vérifier et récupérer les buffers cachés.",
            "status": "done",
            "testStrategy": "Tester que le cache stocke et récupère correctement les AudioBuffer avec les bonnes clés. Vérifier que clearCache() vide effectivement le cache et que des paramètres identiques utilisent le cache.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T20:20:23.229Z"
          },
          {
            "id": 4,
            "title": "Implémenter le debounce et la gestion du Web Worker",
            "description": "Ajouter le système de debounce 500ms et la création/gestion du Web Worker rubberband pour éviter les traitements multiples",
            "dependencies": [
              3
            ],
            "details": "Créer une propriété private debounceTimer: number | null = null. Implémenter la logique de debounce avec clearTimeout/setTimeout de 500ms dans les méthodes de changement de paramètres. Créer une propriété private worker: Worker | null = null. Implémenter createWorker() qui instancie le Worker depuis './workers/rubberband.worker.ts'. Implémenter destroyWorker() qui termine le worker existant. Ajouter la gestion des messages worker.onmessage pour recevoir les résultats.",
            "status": "done",
            "testStrategy": "Tester que le debounce fonctionne en appelant rapidement setPitch() et vérifier qu'un seul traitement est déclenché après 500ms. Vérifier que le Worker est correctement créé et détruit.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T20:25:45.702Z"
          },
          {
            "id": 5,
            "title": "Implémenter l'API publique du service",
            "description": "Créer les méthodes publiques loadOriginalBuffer(), setPitch(), setPlaybackRate(), getProcessedBuffer() Observable, et finaliser l'intégration",
            "dependencies": [
              4
            ],
            "details": "Implémenter loadOriginalBuffer(buffer: AudioBuffer): void qui stocke le buffer original. Implémenter setPitch(semitones: number): void qui met à jour le signal et déclenche le traitement avec debounce. Implémenter setPlaybackRate(rate: number): void similaire pour la vitesse. Implémenter getProcessedBuffer(): Observable<AudioBuffer> qui retourne un Observable émettant les buffers traités. Créer une propriété private processedBufferSubject = new Subject<AudioBuffer>(). Intégrer la logique complète de traitement avec vérification du cache, envoi au Worker, et émission du résultat.",
            "status": "done",
            "testStrategy": "Tester l'API complète : charger un buffer original, modifier le pitch/tempo, vérifier que getProcessedBuffer() émet le buffer traité. Tester que les paramètres identiques utilisent le cache et que les nouveaux paramètres déclenchent un nouveau traitement.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T20:29:11.633Z"
          }
        ],
        "updatedAt": "2025-10-17T20:29:11.633Z"
      },
      {
        "id": 5,
        "title": "Intégration RubberbandEngineService dans ToneEngineService",
        "description": "Modifier ToneEngineService pour injecter RubberbandEngineService et gérer le remplacement de buffer",
        "details": "Dans src/app/features/audio-looper/services/tone-engine.service.ts, injecter RubberbandEngineService. Ajouter la propriété originalAudioBuffer pour stocker le buffer original. Modifier loadAudioFile() pour envoyer le buffer à rubberband via loadOriginalBuffer() et s'abonner à getProcessedBuffer(). Implémenter replaceAudioBuffer() qui préserve la position de lecture et l'état playing/paused lors du remplacement. Implémenter adjustLoopPoints() pour ajuster les marqueurs A/B selon la nouvelle durée.",
        "testStrategy": "Tester le chargement d'un fichier audio et vérifier que le buffer original est envoyé à rubberband. Tester le remplacement de buffer en s'assurant que la position de lecture et l'état sont conservés. Vérifier que les marqueurs A/B restent valides après traitement.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Injection RubberbandEngineService dans ToneEngineService",
            "description": "Injecter RubberbandEngineService dans ToneEngineService via le constructeur ou la fonction inject()",
            "dependencies": [],
            "details": "Dans src/app/features/audio-looper/services/tone-engine.service.ts, ajouter l'injection de RubberbandEngineService en utilisant la fonction inject() pour respecter les conventions Angular modernes. Déclarer la propriété private rubberbandEngine = inject(RubberbandEngineService).",
            "status": "done",
            "testStrategy": "Vérifier que le service s'injecte correctement sans erreurs et qu'il est accessible dans les méthodes de ToneEngineService",
            "updatedAt": "2025-10-18T06:36:55.330Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Ajout de la propriété originalAudioBuffer",
            "description": "Ajouter une propriété pour stocker le buffer audio original avant traitement",
            "dependencies": [
              1
            ],
            "details": "Ajouter la propriété private originalAudioBuffer: AudioBuffer | null = null dans ToneEngineService. Cette propriété servira à conserver une référence vers le buffer audio original pour pouvoir le repasser au Web Worker rubberband lors des changements de paramètres.",
            "status": "done",
            "testStrategy": "Vérifier que la propriété est correctement déclarée et initialisée à null",
            "parentId": "undefined",
            "updatedAt": "2025-10-18T06:38:13.423Z"
          },
          {
            "id": 3,
            "title": "Modification de loadAudioFile() pour intégration rubberband",
            "description": "Modifier la méthode loadAudioFile() pour envoyer le buffer à rubberband et s'abonner aux résultats",
            "dependencies": [
              2
            ],
            "details": "Dans loadAudioFile(), après la création du buffer audio, stocker le buffer dans originalAudioBuffer. Appeler rubberbandEngine.loadOriginalBuffer(buffer) pour envoyer le buffer au Web Worker. S'abonner à rubberbandEngine.getProcessedBuffer() pour recevoir les buffers traités. Gérer les cas d'erreur et de progression du traitement.",
            "status": "done",
            "testStrategy": "Tester le chargement d'un fichier audio et vérifier que le buffer original est correctement stocké et envoyé au service rubberband",
            "parentId": "undefined",
            "updatedAt": "2025-10-18T06:43:00.823Z"
          },
          {
            "id": 4,
            "title": "Implémentation de replaceAudioBuffer()",
            "description": "Créer une méthode qui remplace le buffer audio en préservant l'état de lecture",
            "dependencies": [
              3
            ],
            "details": "Implémenter la méthode replaceAudioBuffer(newBuffer: AudioBuffer) qui sauvegarde la position de lecture actuelle et l'état playing/paused, remplace le buffer de la source Tone.js, puis restaure la position et l'état. Gérer les cas où la nouvelle durée est plus courte que la position actuelle.",
            "status": "done",
            "testStrategy": "Tester le remplacement de buffer en s'assurant que la lecture continue à la même position relative et que l'état playing/paused est conservé",
            "parentId": "undefined",
            "updatedAt": "2025-10-18T06:46:08.637Z"
          },
          {
            "id": 5,
            "title": "Implémentation de adjustLoopPoints()",
            "description": "Créer une méthode pour ajuster les marqueurs A/B selon la nouvelle durée après traitement",
            "dependencies": [
              4
            ],
            "details": "Implémenter adjustLoopPoints(oldDuration: number, newDuration: number) qui calcule le ratio de changement de durée et ajuste proportionnellement les marqueurs A/B. Vérifier que les nouveaux points restent dans les limites du buffer. Émettre les nouveaux points via les signals appropriés.",
            "status": "done",
            "testStrategy": "Vérifier que les marqueurs A/B sont correctement ajustés proportionnellement à la nouvelle durée et restent dans les limites valides du buffer traité",
            "parentId": "undefined",
            "updatedAt": "2025-10-18T06:46:57.165Z"
          }
        ],
        "updatedAt": "2025-10-18T06:46:57.165Z"
      },
      {
        "id": 6,
        "title": "Création du composant RubberbandPitchControlComponent",
        "description": "Créer le composant UI pour le contrôle du pitch avec slider et indicateur de progression",
        "details": "Créer src/app/features/audio-looper/ui/rubberband-pitch-control/ avec les fichiers component.ts, component.html, component.scss et index.ts. Implémenter le template avec slider -6 à +6, affichage de la valeur courante, bouton Reset Pitch, et indicateur de progression conditionnel (@if). Injecter ToneEngineService et RubberbandEngineService. Implémenter onPitchChange() qui appelle toneEngine.setPitch(). Utiliser les signals pour l'affichage réactif.",
        "testStrategy": "Tester l'affichage du composant, le fonctionnement du slider, la mise à jour de la valeur affichée, le bouton Reset, et l'apparition/disparition de l'indicateur de progression pendant le traitement.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Création de la structure de dossier et des fichiers de base",
            "description": "Créer la structure de dossier src/app/features/audio-looper/ui/rubberband-pitch-control/ avec tous les fichiers nécessaires",
            "dependencies": [],
            "details": "Créer le dossier src/app/features/audio-looper/ui/rubberband-pitch-control/ et y ajouter les fichiers rubberband-pitch-control.component.ts, rubberband-pitch-control.component.html, rubberband-pitch-control.component.scss et index.ts. Le fichier index.ts doit exporter le composant selon les conventions barrel exports du projet.",
            "status": "done",
            "testStrategy": "Vérifier que tous les fichiers sont créés dans la bonne structure de dossier et que le composant peut être importé via le fichier index.ts",
            "updatedAt": "2025-10-18T06:59:37.876Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implémentation de la logique TypeScript du composant",
            "description": "Développer la classe RubberbandPitchControlComponent avec injection des services et gestion des signals",
            "dependencies": [
              1
            ],
            "details": "Implémenter la classe component avec injection de ToneEngineService et RubberbandEngineService via inject(). Créer les signals pour pitch value, isProcessing, et autres états réactifs. Implémenter les méthodes onPitchChange() pour appeler toneEngine.setPitch() et resetPitch() pour remettre à 0. Configurer le composant en standalone avec les imports nécessaires.",
            "status": "done",
            "testStrategy": "Compiler le composant sans erreurs TypeScript et vérifier que les services sont correctement injectés",
            "parentId": "undefined",
            "updatedAt": "2025-10-18T07:00:22.720Z"
          },
          {
            "id": 3,
            "title": "Création du template HTML avec slider et contrôles",
            "description": "Développer le template HTML avec slider de -6 à +6, affichage de valeur, bouton Reset et indicateur de progression",
            "dependencies": [
              2
            ],
            "details": "Créer le template avec header contenant label et affichage de la valeur courante, slider HTML avec range -6 à +6 et step 0.1, bouton 'Reset Pitch' pour remettre à zéro, et section conditionnelle (@if) pour l'indicateur de progression pendant le traitement. Utiliser les bindings Angular appropriés pour les events et la réactivité.",
            "status": "done",
            "testStrategy": "Vérifier que le slider fonctionne correctement, que la valeur s'affiche en temps réel, que le bouton reset fonctionne, et que l'indicateur apparaît conditionnellement",
            "parentId": "undefined",
            "updatedAt": "2025-10-18T07:01:01.741Z"
          },
          {
            "id": 4,
            "title": "Implémentation des styles SCSS avec design responsive",
            "description": "Développer les styles SCSS pour le composant avec design responsive et animation de progression",
            "dependencies": [
              3
            ],
            "details": "Créer les styles pour .pitch-control avec header, slider-container, bouton reset, et section processing. Implémenter la barre de progression animée avec .progress-bar et .progress-fill. Assurer la responsivité pour mobile, tablette et desktop. Utiliser les variables SCSS existantes du projet pour maintenir la cohérence visuelle.",
            "status": "done",
            "testStrategy": "Tester l'affichage sur différentes tailles d'écran, vérifier l'animation de la barre de progression, et s'assurer que les contrôles sont utilisables sur écran tactile",
            "parentId": "undefined",
            "updatedAt": "2025-10-18T07:01:49.137Z"
          },
          {
            "id": 5,
            "title": "Mise à jour du fichier index.ts du dossier ui",
            "description": "Ajouter l'export du nouveau composant dans le fichier index.ts principal du dossier ui",
            "dependencies": [
              4
            ],
            "details": "Modifier le fichier src/app/features/audio-looper/ui/index.ts pour ajouter l'export 'export * from './rubberband-pitch-control';' afin que le composant soit accessible via les barrel exports. Vérifier que l'export fonctionne correctement et que le composant peut être importé depuis './ui'.",
            "status": "done",
            "testStrategy": "Vérifier que le composant peut être importé via 'import { RubberbandPitchControlComponent } from './ui' et compiler le projet sans erreurs",
            "parentId": "undefined",
            "updatedAt": "2025-10-18T07:02:24.213Z"
          }
        ],
        "updatedAt": "2025-10-18T07:02:24.213Z"
      },
      {
        "id": 7,
        "title": "Styling SCSS du composant RubberbandPitchControlComponent",
        "description": "Implémenter les styles SCSS pour le contrôle pitch avec design responsive et indicateur de progression",
        "details": "Dans rubberband-pitch-control.component.scss, créer les styles pour .pitch-control avec header (label + valeur), slider-container, bouton reset, et section processing. Implémenter la barre de progression animée avec .progress-bar et .progress-fill. Assurer la cohérence avec les styles existants du module audio-looper. Implémenter le responsive design pour mobile, tablette et desktop. Utiliser les variables SCSS existantes si disponibles.",
        "testStrategy": "Tester l'affichage sur différentes tailles d'écran (mobile, tablette, desktop). Vérifier que l'indicateur de progression s'anime correctement et que les contrôles sont utilisables sur écran tactile. Vérifier la cohérence visuelle avec les autres composants du module.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-19T07:00:16.554Z"
      },
      {
        "id": 8,
        "title": "Intégration du composant dans AudioLooperContainerComponent",
        "description": "Ajouter RubberbandPitchControlComponent dans le template du container principal",
        "details": "Dans src/app/features/audio-looper/ui/audio-looper-container/audio-looper-container.component.html, ajouter <app-rubberband-pitch-control></app-rubberband-pitch-control> après le commentaire '<!-- Les autres contrôles seront ajoutés dans les prochaines tâches -->'. Importer le composant dans audio-looper-container.component.ts via le fichier index.ts. Vérifier que le composant s'affiche correctement dans l'interface.",
        "testStrategy": "Charger l'application, naviguer vers le module Audio Looper, et vérifier que le contrôle pitch rubberband s'affiche correctement dans la section des contrôles. Tester l'interaction avec le slider et vérifier qu'il n'y a pas d'erreurs dans la console.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-19T07:09:43.775Z"
      },
      {
        "id": 9,
        "title": "Modification de WaveformDisplayComponent pour la régénération",
        "description": "Modifier WaveformDisplayComponent pour régénérer automatiquement la waveform lors du changement de buffer",
        "details": "Dans src/app/features/audio-looper/ui/waveform-display/waveform-display.component.ts, ajouter un effect() qui écoute les changements de duration du ToneEngineService. Implémenter regenerateWaveform() qui récupère le nouveau buffer via this.player.buffer.get() et redessine la waveform. Conserver les marqueurs A/B et la position du curseur de lecture. Utiliser effect() d'Angular pour réagir automatiquement aux changements.",
        "testStrategy": "Charger un fichier audio, modifier le pitch, et vérifier que la waveform se régénère automatiquement après le traitement. Vérifier que les marqueurs A/B et le curseur de lecture restent aux bonnes positions. Tester avec différents changements de pitch.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-19T19:31:43.160Z"
      },
      {
        "id": 10,
        "title": "Implémentation du cache et optimisation des performances",
        "description": "Optimiser le système de cache du RubberbandEngineService et améliorer les performances",
        "details": "Dans rubberband-engine.service.ts, optimiser la logique de cache avec getCacheKey() basé sur pitch et tempo. Implémenter clearCache() pour la gestion mémoire. Optimiser le debounce pour éviter les traitements inutiles. Ajouter la gestion de l'annulation des traitements en cours (Worker.terminate()). Implémenter le throttling des messages de progression (250ms) côté service.",
        "testStrategy": "Tester le cache en changeant plusieurs fois le pitch et en revenant aux valeurs précédentes (doit être instantané). Tester l'annulation en changeant rapidement le pitch plusieurs fois. Vérifier que les performances restent fluides même avec des fichiers de 10MB.",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-19T19:41:03.064Z"
      },
      {
        "id": 11,
        "title": "Gestion des erreurs et fallback",
        "description": "Implémenter la gestion d'erreurs pour le chargement de rubberband-wasm et le traitement audio",
        "details": "Ajouter la gestion d'erreurs dans le Web Worker pour le chargement de rubberband-wasm (fichiers manquants, erreurs WASM). Dans RubberbandEngineService, implémenter la gestion des erreurs de traitement et des timeouts. Ajouter des messages d'erreur utilisateur clairs dans le composant UI. Implémenter un fallback vers Tone.js PitchShift en cas d'échec de rubberband. Ajouter des logs console pour le debugging.",
        "testStrategy": "Tester avec des fichiers corrompus, simuler l'indisponibilité des assets rubberband, et vérifier que l'application reste utilisable avec des messages d'erreur clairs. Vérifier que le fallback vers Tone.js fonctionne correctement.",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-19T19:54:35.606Z"
      },
      {
        "id": 12,
        "title": "Tests de compatibilité cross-browser et WebAssembly",
        "description": "Tester la compatibilité rubberband-wasm sur différents navigateurs et implémenter les détections nécessaires",
        "details": "Tester rubberband-wasm sur Chrome, Firefox, Safari et Edge. Implémenter la détection du support WebAssembly au démarrage. Ajouter des messages informatifs si WebAssembly n'est pas supporté. Tester sur mobile (iOS Safari, Chrome Android). Implémenter des polyfills si nécessaire. Vérifier les performances sur différentes plateformes.",
        "testStrategy": "Tester l'application sur Chrome, Firefox, Safari et Edge (desktop et mobile). Vérifier que rubberband-wasm se charge correctement et que le traitement audio fonctionne. Tester sur des appareils moins puissants pour vérifier les performances.",
        "priority": "medium",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-19T20:03:12.254Z"
      },
      {
        "id": 13,
        "title": "Synchronisation avec les autres contrôles audio",
        "description": "Assurer la compatibilité entre le pitch rubberband et les autres contrôles (vitesse, volume, loop)",
        "details": "Vérifier que le contrôle de vitesse (playback rate) fonctionne correctement avec les buffers traités par rubberband. Tester la compatibilité avec le contrôle de volume et les marqueurs de boucle A/B. Implémenter la synchronisation entre ToneEngineService et RubberbandEngineService pour éviter les conflits. Tester les interactions entre tous les contrôles audio simultanément.",
        "testStrategy": "Charger un fichier, modifier le pitch avec rubberband, puis tester tous les autres contrôles (vitesse 0.5x/0.75x/1.0x, volume, boucle A/B, lecture/pause, seek). Vérifier qu'il n'y a pas de conflits ou de comportements inattendus.",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-19T20:11:28.368Z"
      },
      {
        "id": 14,
        "title": "Tests de qualité audio et validation des algorithmes",
        "description": "Effectuer des tests approfondis de qualité audio pour valider l'amélioration par rapport à Tone.js",
        "details": "Tester le pitch shift de -6 à +6 demi-tons avec différents types de fichiers audio (voix, musique, instruments). Comparer la qualité audio entre Tone.js PitchShift et rubberband-wasm. Vérifier l'absence d'artefacts (distorsion, phasing, effet chipmunk). Tester avec des fichiers de différentes qualités (MP3 128kbps, 320kbps, WAV). Documenter les améliorations de qualité observées.",
        "testStrategy": "Préparer des fichiers de test variés (guitare, piano, voix, musique complète). Tester chaque valeur de pitch (-6 à +6) et comparer avec Tone.js. Écouter attentivement pour détecter les artefacts. Faire valider la qualité audio par un utilisateur musical si possible.",
        "priority": "high",
        "dependencies": [
          "13"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-19T20:19:01.028Z"
      },
      {
        "id": 15,
        "title": "Documentation et nettoyage du code",
        "description": "Ajouter la documentation technique, nettoyer le code et effectuer la validation finale",
        "details": "Ajouter des commentaires JSDoc aux méthodes principales de RubberbandEngineService et du Web Worker. Nettoyer les console.logs de debug. Optimiser les imports et vérifier qu'il n'y a pas de code mort. Mettre à jour les fichiers index.ts pour les exports. Effectuer un build de production final et vérifier les performances. Préparer un commit atomique avec un message détaillé.",
        "testStrategy": "Lancer ng build --configuration production et vérifier qu'il n'y a aucune erreur. Tester l'application buildée pour s'assurer que toutes les fonctionnalités marchent en mode production. Vérifier que la taille du bundle reste raisonnable avec l'ajout de rubberband-wasm.",
        "priority": "low",
        "dependencies": [
          "14"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-19T20:26:20.790Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-19T20:26:20.794Z",
      "taskCount": 15,
      "completedCount": 15,
      "tags": [
        "rubberband-wasm-pitch"
      ],
      "created": "2025-10-19T20:58:13.296Z",
      "description": "Tasks for rubberband-wasm-pitch context",
      "updated": "2025-10-19T20:58:13.296Z"
    }
  },
  "audio-favoris": {
    "tasks": [
      {
        "id": "1",
        "title": "Mise en place de l'architecture du système de favoris",
        "description": "Créer la structure de base du module favoris avec les services, interfaces et modèles de données",
        "details": "Créer un service FavoriteService avec les méthodes de base (add, remove, list, update), définir les interfaces TypeScript pour FavoriteModel et FavoriteSettings, créer les types pour le stockage localStorage et IndexedDB. Implémenter la structure de données JSON avec validation des limites (10 favoris max, 100MB total).",
        "testStrategy": "Tests unitaires sur les interfaces et validation des limites de stockage",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer les interfaces TypeScript pour le système de favoris",
            "description": "Définir les interfaces FavoriteModel, FavoriteSettings et les types de données pour le stockage",
            "dependencies": [],
            "details": "Créer src/app/features/audio-looper/data/interfaces/favorite.interface.ts avec FavoriteModel (id, fileName, audioData, settings, timestamp, size), FavoriteSettings (pitch, playbackRate, currentTime, loopStart, loopEnd, loopEnabled), et les types pour StorageConfig avec limites (maxFavorites: 10, maxTotalSize: 100MB)",
            "status": "done",
            "testStrategy": "Tests unitaires de validation des interfaces et vérification des contraintes de types",
            "updatedAt": "2025-10-23T20:37:52.317Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implémenter le service de stockage FavoriteStorageService",
            "description": "Créer le service de base pour la gestion du stockage localStorage et IndexedDB",
            "dependencies": [
              1
            ],
            "details": "Créer src/app/features/audio-looper/data/services/favorite-storage.service.ts avec méthodes save(), load(), remove(), calculateTotalSize(), validateLimits(). Utiliser localStorage pour métadonnées et IndexedDB pour données audio. Implémenter la validation des limites 10 favoris max et 100MB total",
            "status": "done",
            "testStrategy": "Tests unitaires des opérations CRUD et validation des limites de stockage",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T20:41:47.740Z"
          },
          {
            "id": 3,
            "title": "Développer le service métier FavoriteService",
            "description": "Créer le service principal avec les méthodes de gestion des favoris",
            "dependencies": [
              2
            ],
            "details": "Créer src/app/features/audio-looper/data/services/favorite.service.ts avec méthodes add(), remove(), list(), update(), getById(). Utiliser Angular signals pour la réactivité. Implémenter la logique métier: génération d'ID unique (timestamp), validation des données, gestion des erreurs et notifications toast",
            "status": "done",
            "testStrategy": "Tests unitaires des méthodes métier et tests d'intégration avec le service de stockage",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T20:43:12.566Z"
          },
          {
            "id": 4,
            "title": "Créer les modèles de données et utilitaires de validation",
            "description": "Implémenter les classes de modèles et les fonctions utilitaires de validation",
            "dependencies": [
              1
            ],
            "details": "Créer src/app/features/audio-looper/data/models/favorite.model.ts avec classe FavoriteModel et méthodes de validation. Créer src/app/features/audio-looper/utils/favorite-validators.ts avec fonctions validateFileSize(), validateFavoriteLimit(), formatFileSize(), generateUniqueId()",
            "status": "done",
            "testStrategy": "Tests unitaires des validateurs et méthodes de formatage",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T20:45:01.573Z"
          },
          {
            "id": 5,
            "title": "Intégrer les favoris dans l'architecture du module audio-looper",
            "description": "Configurer l'injection des services et l'intégration avec les composants existants",
            "dependencies": [
              3,
              4
            ],
            "details": "Mettre à jour src/app/features/audio-looper/audio-looper.component.ts pour injecter FavoriteService. Créer src/app/features/audio-looper/data/index.ts pour les barrel exports. Ajouter les imports nécessaires et configurer la structure modulaire selon les conventions du projet",
            "status": "done",
            "testStrategy": "Tests d'intégration pour vérifier l'injection des dépendances et la communication entre services",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T20:48:51.304Z"
          }
        ],
        "updatedAt": "2025-10-23T20:48:51.304Z"
      },
      {
        "id": "2",
        "title": "Implémentation du stockage localStorage pour métadonnées",
        "description": "Cette tâche était prévue pour développer la couche de persistance localStorage, mais la fonctionnalité a déjà été implémentée dans FavoriteStorageService (tâche 1.2)",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "La fonctionnalité de stockage localStorage est déjà complètement implémentée dans FavoriteStorageService. Le service utilise localStorage.setItem(this.STORAGE_KEY) pour stocker les métadonnées (count, lastUpdated, ids) et la méthode updateMetadata() est appelée automatiquement après chaque save/remove. Cette implémentation couvre tous les besoins initialement prévus pour cette tâche.",
        "testStrategy": "Les tests sont déjà couverts par l'implémentation existante de FavoriteStorageService dans la tâche 1.2",
        "subtasks": [],
        "updatedAt": "2025-10-23T21:08:44.136Z"
      },
      {
        "id": "3",
        "title": "Implémentation du stockage IndexedDB pour buffers audio",
        "description": "Cette tâche était prévue pour développer la couche IndexedDB pour stocker les buffers audio, mais la fonctionnalité a déjà été complètement implémentée dans FavoriteStorageService (tâche 1.2)",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "details": "La fonctionnalité IndexedDB est déjà complètement implémentée dans FavoriteStorageService (tâche 1.2). Le service utilise IndexedDB avec initIndexedDB(), object store 'favorites' avec keyPath 'id', et toutes les méthodes CRUD (save, load, loadAll, remove, clearAll) via des transactions. Les buffers audio sont stockés en Base64 dans le champ audioData de chaque FavoriteModel. L'implémentation couvre tous les besoins initialement prévus : sauvegarde des buffers audio complets, gestion des clés uniques basées sur timestamp, gestion des erreurs de corruption, et nettoyage automatique des entrées.",
        "testStrategy": "Les tests sont déjà couverts par l'implémentation existante de FavoriteStorageService dans la tâche 1.2. L'intégration avec de vrais buffers audio et la gestion des erreurs sont fonctionnelles.",
        "subtasks": [],
        "updatedAt": "2025-10-23T21:10:27.182Z"
      },
      {
        "id": "4",
        "title": "Création du bouton étoile dans la barre upload minimisée",
        "description": "Ajouter le bouton étoile avec états visuels (vide/plein) dans la barre upload existante",
        "details": "Modifier le composant upload-bar pour inclure un bouton étoile à côté du titre. États: étoile vide (outline) pour non-favori, étoile pleine dorée + badge 'Favori' pour favori actif. Gestion du clic avec vérification de la limite de 10 favoris.",
        "testStrategy": "Tests visuels des états et tests d'interaction utilisateur",
        "priority": "medium",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Ajout de la structure du bouton étoile dans le composant upload minimisé",
            "description": "Créer la structure HTML du bouton étoile dans la barre upload minimisée du composant audio-looper-container",
            "dependencies": [],
            "details": "Modifier le template audio-looper-container.component.html section 'minimized-upload' pour ajouter un bouton étoile entre l'icône/nom de fichier et le bouton 'Change File'. Le bouton doit contenir l'icône SVG d'étoile et le badge 'Favori' conditionnel.",
            "status": "done",
            "testStrategy": "Vérification visuelle de l'affichage du bouton dans l'interface upload minimisée",
            "updatedAt": "2025-10-23T21:34:27.516Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implémentation de la logique d'état du bouton étoile",
            "description": "Créer les signals et computed pour gérer l'état favori/non-favori du fichier actuel",
            "dependencies": [
              1
            ],
            "details": "Ajouter dans audio-looper-container.component.ts les signals pour détecter si le fichier actuel est un favori. Utiliser le FavoriteService.hasFileByName() pour vérifier si le fichier est déjà en favori. Créer un computed signal pour l'état du bouton (étoile vide/pleine).",
            "status": "done",
            "testStrategy": "Tests unitaires sur les computed signals et vérification de la détection d'état",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T21:34:31.689Z"
          },
          {
            "id": 3,
            "title": "Création des styles SCSS pour les états du bouton étoile",
            "description": "Définir les styles visuels pour les états vide, plein et survol du bouton étoile",
            "dependencies": [
              1
            ],
            "details": "Dans audio-looper-container.component.scss, créer les classes pour le bouton étoile : état normal (étoile outline), état actif (étoile dorée pleine), état hover, et le style du badge 'Favori'. Utiliser les couleurs dorées pour l'état actif et respecter le design system existant.",
            "status": "done",
            "testStrategy": "Tests visuels des différents états du bouton et vérification du badge",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T21:34:35.753Z"
          },
          {
            "id": 4,
            "title": "Implémentation de la gestion du clic sur le bouton étoile",
            "description": "Créer la logique de basculement favori/non-favori avec vérification des limites",
            "dependencies": [
              2
            ],
            "details": "Implémenter la méthode toggleFavorite() dans audio-looper-container.component.ts. Si non-favori : vérifier la limite de 10 favoris via FavoriteService.canAddMore(), puis ajouter avec FavoriteService.add(). Si favori : supprimer avec FavoriteService.remove(). Gérer les messages d'erreur et de confirmation.",
            "status": "done",
            "testStrategy": "Tests d'interaction utilisateur et vérification de la limite de 10 favoris",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T21:34:39.841Z"
          },
          {
            "id": 5,
            "title": "Integration des messages de feedback utilisateur",
            "description": "Ajouter les notifications toast/snackbar pour confirmer les actions sur les favoris",
            "dependencies": [
              4
            ],
            "details": "Intégrer un système de notifications pour afficher les messages de succès ('Ajouté aux favoris', 'Retiré des favoris') et d'erreur ('Limite de 10 favoris atteinte'). Utiliser un service de notification ou créer un composant toast simple. Afficher les messages pendant 3 secondes.",
            "status": "done",
            "testStrategy": "Tests d'affichage des notifications et validation des messages appropriés",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T21:34:43.783Z"
          }
        ],
        "updatedAt": "2025-10-23T21:34:43.783Z"
      },
      {
        "id": "5",
        "title": "Implémentation de l'ajout aux favoris avec validation des limites",
        "description": "Développer la logique d'ajout d'un favori avec sauvegarde des réglages audio et validation des contraintes",
        "details": "Créer addToFavorites() qui capture: pitch, playbackRate, currentTime, loopStart/End, loopEnabled. Validation limite 10 favoris et 100MB total. Sauvegarde timestamp comme ID unique. Gestion du feedback utilisateur avec toasts.",
        "testStrategy": "Tests des cas limites (10 favoris, 100MB) et validation des données sauvegardées",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implémentation de la méthode addToFavorites dans FavoriteService",
            "description": "Créer la méthode addToFavorites() qui capture les réglages audio actuels et appelle le service de sauvegarde avec validation",
            "dependencies": [],
            "details": "Ajouter une méthode addToFavorites(file: File, audioBuffer: AudioBuffer) dans FavoriteService qui extrait mimeType, size, et duration du fichier/buffer, capture les réglages actuels depuis AudioPlayerService et ToneEngineService (pitch, playbackRate, currentTime, loopStart/End, loopEnabled), puis appelle la méthode add() existante avec génération automatique d'ID timestamp unique",
            "status": "done",
            "testStrategy": "Tests unitaires pour vérifier la capture correcte des réglages et l'appel à la méthode save avec les bonnes données",
            "updatedAt": "2025-10-24T14:42:10.668Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Intégration des réglages audio actuels pour la capture d'état",
            "description": "Développer la logique de capture des réglages audio depuis AudioPlayerService et ToneEngineService pour la sauvegarde en favoris",
            "dependencies": [
              1
            ],
            "details": "Créer des méthodes helper dans AudioLooperContainerComponent pour extraire les réglages actuels : getCurrentAudioSettings() qui récupère pitch/vitesse depuis ToneEngineService, volume/mute depuis AudioPlayerService, loopStart/End/Enabled depuis les contrôles de boucle, currentTime de la position de lecture. Ces réglages seront passés à FavoriteService.addToFavorites()",
            "status": "in-progress",
            "testStrategy": "Tests d'intégration pour vérifier que tous les réglages audio sont correctement capturés à l'instant T",
            "parentId": "undefined",
            "updatedAt": "2025-10-24T14:42:13.835Z"
          },
          {
            "id": 3,
            "title": "Implémentation de la validation des limites de stockage",
            "description": "Ajouter la validation avant sauvegarde pour respecter la limite de 10 favoris et 100MB total avec gestion des erreurs appropriées",
            "dependencies": [
              1
            ],
            "details": "Améliorer la méthode addToFavorites() pour vérifier via FavoriteStorageService.canAddFavorite() les contraintes : nombre de favoris < 10, taille totale + nouveau fichier < 100MB. Retourner ValidationResult avec errorCode 'MAX_FAVORITES' ou 'MAX_SIZE' si limites dépassées. Utiliser les computed signals canAddMore et storageStats pour les vérifications",
            "status": "pending",
            "testStrategy": "Tests des cas limites : ajout du 10ème favori (succès), ajout du 11ème (échec), fichier dépassant 100MB total (échec)",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implémentation du système de feedback utilisateur avec toasts",
            "description": "Créer un système de notifications toast pour informer l'utilisateur du succès ou échec des opérations de favoris",
            "dependencies": [
              3
            ],
            "details": "Créer un service ToastService simple avec show(message, type: 'success'|'error'|'warning') et timeout auto. Intégrer dans AudioLooperContainerComponent.toggleFavorite() pour afficher : 'Favori ajouté avec succès', 'Limite de 10 favoris atteinte', 'Taille maximale de 100MB dépassée', 'Erreur lors de la sauvegarde'. Composant toast simple en position fixed top-right avec animations",
            "status": "pending",
            "testStrategy": "Tests d'affichage des différents types de toasts selon les résultats d'opération",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Finalisation de l'intégration complète dans toggleFavorite()",
            "description": "Remplacer le placeholder dans toggleFavorite() par l'appel effectif à addToFavorites avec gestion complète des réglages et feedback",
            "dependencies": [
              2,
              4
            ],
            "details": "Modifier AudioLooperContainerComponent.toggleFavorite() pour remplacer le TODO/alert par : récupération du File original (stocker référence lors onFileSelected), capture des réglages via getCurrentAudioSettings(), appel à favoriteService.addToFavorites(), gestion du ValidationResult avec affichage des toasts appropriés, mise à jour de l'état du composant. Supprimer les placeholders existants",
            "status": "pending",
            "testStrategy": "Tests end-to-end : chargement fichier, modification réglages, ajout favori, vérification sauvegarde et feedback utilisateur",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-24T14:50:14.010Z"
      },
      {
        "id": "6",
        "title": "Création de la modal de gestion des limites (10 favoris max)",
        "description": "Développer la modal qui s'affiche quand l'utilisateur tente d'ajouter un 11ème favori",
        "details": "Créer FavoriteQuotaModalComponent avec liste complète des favoris (titre, durée, date, taille, bouton supprimer). L'utilisateur doit supprimer un favori pour libérer l'espace avant d'ajouter le nouveau. Auto-ajout du nouveau favori après suppression.",
        "testStrategy": "Tests d'interaction pour suppression et ajout automatique",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le composant FavoriteQuotaModalComponent",
            "description": "Générer et structurer le composant modal de base pour la gestion des limites de favoris",
            "dependencies": [],
            "details": "Utiliser ng generate component pour créer features/audio-looper/ui/favorite-quota-modal avec template HTML séparé, styles SCSS et logique TypeScript. Configurer la structure de base avec inputs/outputs nécessaires pour recevoir la liste des favoris et émettre les événements de suppression.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Développer l'interface utilisateur de la modal",
            "description": "Créer le template HTML et les styles SCSS pour afficher la liste complète des favoris",
            "dependencies": [
              1
            ],
            "details": "Implémenter le template avec overlay modal, header explicatif 'Limite atteinte (10/10)', liste scrollable des favoris avec titre, durée, date d'ajout, taille du fichier pour chaque entrée. Styles responsive avec boutons de suppression clairement visibles et touch-friendly.",
            "status": "pending",
            "testStrategy": null,
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Intégrer la fonctionnalité de suppression des favoris",
            "description": "Implémenter la logique de suppression d'un favori depuis la modal",
            "dependencies": [
              2
            ],
            "details": "Connecter les boutons de suppression avec le FavoriteService pour supprimer un favori sélectionné. Gérer la confirmation de suppression avec feedback immédiat. Mettre à jour la liste en temps réel après suppression et recalculer l'espace disponible.",
            "status": "pending",
            "testStrategy": "Tests d'interaction pour la suppression avec vérification de la mise à jour de la liste",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implémenter l'auto-ajout du nouveau favori",
            "description": "Développer la logique d'ajout automatique du nouveau favori après suppression",
            "dependencies": [
              3
            ],
            "details": "Après suppression réussie d'un favori, déclencher automatiquement l'ajout du nouveau favori en attente. Gérer la séquence: suppression → validation de l'espace libre → ajout automatique → fermeture de la modal → feedback utilisateur avec toast de confirmation.",
            "status": "pending",
            "testStrategy": "Tests de la séquence complète suppression-ajout avec validation des états intermédiaires",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Intégrer la modal dans le système de favoris existant",
            "description": "Connecter la modal avec le système de gestion des favoris et gérer son affichage",
            "dependencies": [
              4
            ],
            "details": "Intégrer l'appel de la modal dans FavoriteService quand la limite est atteinte. Gérer l'ouverture/fermeture de la modal, passer les données des favoris existants, et coordonner avec les autres composants. Implémenter la gestion des états de chargement et d'erreur.",
            "status": "pending",
            "testStrategy": "Tests d'intégration avec validation du déclenchement automatique de la modal et coordination avec les autres composants",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2025-10-24T16:10:18.572Z"
      },
      {
        "id": "7",
        "title": "Création du composant sidebar des favoris",
        "description": "Développer le sidebar coulissant latéral pour afficher la liste des favoris",
        "details": "Créer FavoritesSidebarComponent avec drawer depuis la gauche, overlay semi-transparent. Header avec titre, compteur '7/10 favoris • 45 MB / 100 MB', boutons 'Modifier l'ordre' et 'Upload nouveau fichier'. Footer avec bouton fermer.",
        "testStrategy": "Tests responsive mobile/desktop et animations d'ouverture/fermeture",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le composant FavoritesSidebarComponent avec structure de base",
            "description": "Générer le composant sidebar avec sa structure de fichiers et architecture Angular standalone",
            "dependencies": [],
            "details": "Créer le répertoire src/app/features/audio-looper/ui/favorites-sidebar/ avec tous les fichiers nécessaires (component.ts, component.html, component.scss, index.ts). Configurer le composant en standalone avec les imports de base et créer la structure HTML de base avec header, contenu et footer. Ajouter l'export dans ui/index.ts.",
            "status": "done",
            "testStrategy": "Vérifier que le composant se génère sans erreur et s'affiche dans l'application",
            "updatedAt": "2025-10-23T21:16:18.747Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implémenter l'overlay semi-transparent et l'animation d'ouverture depuis la gauche",
            "description": "Développer le système d'overlay backdrop et l'animation du drawer coulissant depuis la gauche",
            "dependencies": [
              1
            ],
            "details": "Créer l'overlay backdrop semi-transparent avec backdrop-filter blur en utilisant les patterns CSS du modal existant. Implémenter l'animation de translation X depuis -100% vers 0 pour le drawer. Ajouter les classes CSS pour l'état ouvert/fermé avec transitions fluides. Gérer le z-index approprié (1000) et les animations fadeIn/slideIn comme référence du modal existant.",
            "status": "done",
            "testStrategy": "Tester les animations d'ouverture/fermeture et l'overlay backdrop sur mobile et desktop",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T21:16:23.121Z"
          },
          {
            "id": 3,
            "title": "Développer le header avec titre, compteur de favoris et boutons d'action",
            "description": "Créer le header du sidebar avec titre, statistiques de stockage et boutons de gestion",
            "dependencies": [
              1
            ],
            "details": "Implémenter le header avec titre 'Favoris', compteur dynamique '7/10 favoris • 45 MB / 100 MB' basé sur FavoriteService.storageStats. Ajouter les boutons 'Modifier l'ordre' et 'Upload nouveau fichier' avec styles cohérents. Utiliser les signals computed pour afficher les statistiques en temps réel depuis FavoriteService. Appliquer les styles avec variables CSS et responsive design mobile/desktop.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage des statistiques dynamiques et le responsive design des boutons",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T21:16:27.274Z"
          },
          {
            "id": 4,
            "title": "Implémenter le footer avec bouton fermer et gestion des événements",
            "description": "Créer le footer du sidebar avec bouton de fermeture et logique d'interaction",
            "dependencies": [
              1
            ],
            "details": "Développer le footer avec bouton 'Fermer' utilisant les styles .btn--secondary du modal existant. Implémenter les événements de fermeture (clic bouton, clic overlay, touche Escape). Créer les @Output() pour communiquer avec le composant parent. Gérer la logique d'état ouvert/fermé avec des signals ou @Input/@Output selon l'architecture.",
            "status": "done",
            "testStrategy": "Tester tous les moyens de fermeture du sidebar et la communication avec le parent",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T21:16:31.409Z"
          },
          {
            "id": 5,
            "title": "Intégrer les services FavoriteService et gérer l'état réactif du sidebar",
            "description": "Connecter le sidebar aux services de favoris et implémenter la réactivité avec signals",
            "dependencies": [
              3,
              4
            ],
            "details": "Injecter FavoriteService dans le composant avec inject(). Utiliser les signals favorites, storageStats, hasFavorites et canAddMore pour l'affichage réactif. Implémenter la logique conditionnelle d'affichage (si 0 favori, rediriger vers upload). Gérer les états de chargement et erreurs. Préparer l'intégration future avec FavoriteCardComponent pour la liste des favoris.",
            "status": "done",
            "testStrategy": "Vérifier la réactivité des données, la gestion des états vides et la logique conditionnelle",
            "parentId": "undefined",
            "updatedAt": "2025-10-23T21:18:49.492Z"
          }
        ],
        "updatedAt": "2025-10-23T21:18:49.492Z"
      },
      {
        "id": "8",
        "title": "Création des cartes de favoris avec waveform miniature",
        "description": "Développer les cartes individuelles pour chaque favori dans la liste sidebar",
        "details": "Créer FavoriteCardComponent avec waveform miniature (40-60px), titre tronqué, badges des réglages actifs (pitch, vitesse, boucle A-B), durée/date, taille fichier, boutons Play/Pause et Supprimer. Design responsive touch-friendly.",
        "testStrategy": "Tests d'affichage des différents états de réglages et interactions tactiles",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-24T17:52:33.167Z"
      },
      {
        "id": "9",
        "title": "Implémentation du chargement d'un favori avec restauration complète",
        "description": "Développer la logique de chargement d'un favori qui restaure tous les réglages et la position de lecture",
        "details": "Créer loadFavorite() qui charge le buffer IndexedDB, applique pitch/vitesse/boucles A-B, positionne currentTime à la position sauvegardée. Volume par défaut à 100%. Ne lance PAS la lecture automatiquement. Fermeture auto du sidebar. Mise à jour du badge étoile.",
        "testStrategy": "Tests de restauration précise des réglages et validation de la position de lecture",
        "priority": "high",
        "dependencies": [
          "8",
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Bouton 'Sauvegarder les modifications' pour favoris existants",
        "description": "Ajouter un bouton pour mettre à jour un favori existant quand l'utilisateur modifie ses réglages",
        "details": "Détecter les modifications (pitch, vitesse, boucles, position) d'un favori chargé. Afficher bouton 'Sauvegarder les modifications' dans la barre upload entre titre et badge. Mettre à jour les métadonnées et position de lecture actuelle. Toast de confirmation.",
        "testStrategy": "Tests de détection des modifications et validation de la mise à jour",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "11",
        "title": "Mode édition avec drag & drop pour réorganisation",
        "description": "Implémenter le mode édition permettant de réorganiser l'ordre des favoris par glisser-déposer",
        "details": "Utiliser Angular CDK Drag & Drop pour réorganisation touch-friendly. Mode édition activé par bouton 'Modifier l'ordre': afficher handles de drag (≡), masquer boutons Play/Supprimer, message d'aide. Sauvegarde automatique du nouvel ordre dans localStorage.",
        "testStrategy": "Tests tactiles mobile et desktop, validation de la persistance de l'ordre",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "12",
        "title": "Bouton d'accès au sidebar et logique d'affichage par défaut",
        "description": "Créer le bouton fixe d'accès au sidebar et gérer l'affichage par défaut selon le nombre de favoris",
        "details": "Bouton hamburger/bibliothèque en haut à gauche toujours visible. Logique: si 0 favori → afficher file-upload, si ≥1 favori → sidebar disponible (fermé par défaut). Gestion des états ouvert/fermé avec overlay.",
        "testStrategy": "Tests de la logique d'affichage conditionnel et interactions d'ouverture/fermeture",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "13",
        "title": "Gestion d'erreurs et cas limites",
        "description": "Implémenter la gestion robuste des erreurs de stockage et corruption de données",
        "details": "Try/catch sur IndexedDB avec messages 'Espace de stockage insuffisant'. Détection des buffers corrompus avec option 'Supprimer ce favori corrompu'. Nettoyage automatique des entrées orphelines au démarrage. Validation des doublons par nom+taille.",
        "testStrategy": "Tests de simulation d'erreurs quota, corruption et validation du nettoyage automatique",
        "priority": "medium",
        "dependencies": [
          "3",
          "9"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "14",
        "title": "Feedback utilisateur et toasts de notification",
        "description": "Implémenter tous les messages de feedback utilisateur avec toasts et notifications",
        "details": "Créer NotificationService pour toasts: 'Ajouté aux favoris', 'Favori supprimé', 'Modifications enregistrées', 'Ce fichier est déjà dans vos favoris'. États de chargement avec spinners pour gros fichiers. Skeleton loaders pour cartes favoris.",
        "testStrategy": "Tests visuels des notifications et états de chargement",
        "priority": "low",
        "dependencies": [
          "5",
          "9",
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "15",
        "title": "Optimisation responsive et design mobile",
        "description": "Finaliser l'adaptation mobile et desktop avec design cohérent au module audio-looper existant",
        "details": "Mobile (<768px): sidebar pleine largeur 90%, cartes pleine largeur, drag tactile optimisé. Desktop (≥768px): sidebar 320-400px, hover states. Reprendre styles audio-looper existant, boutons textuels, mode sombre compatible. Tests sur différentes tailles d'écran.",
        "testStrategy": "Tests responsive sur mobiles/tablettes/desktop et validation de la cohérence visuelle",
        "priority": "medium",
        "dependencies": [
          "11",
          "12"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-24T17:52:33.174Z",
      "taskCount": 15,
      "completedCount": 8,
      "tags": [
        "audio-favoris"
      ]
    }
  }
}