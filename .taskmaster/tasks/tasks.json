{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialisation du projet Angular avec structure de base",
        "description": "Créer un nouveau projet Angular 19.2 avec les configurations de base et l'architecture standalone components",
        "details": "Utiliser Angular CLI pour créer le projet avec 'ng new youtube-looper --routing --style=scss --standalone'. Configurer angular.json pour utiliser SCSS par défaut. Nettoyer les fichiers générés par défaut et créer la structure de dossiers selon les conventions du projet : src/app/features/, src/app/shared/, src/app/core/. Configurer TypeScript en mode strict. Installer les dépendances nécessaires.",
        "testStrategy": "Vérifier que 'ng serve' démarre sans erreur, que le projet utilise Angular 19.2, que la structure de dossiers est correcte et que SCSS est configuré par défaut.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Intégration de l'API YouTube IFrame Player",
        "description": "Configurer l'API YouTube IFrame Player et créer un service Angular pour gérer l'intégration",
        "details": "Créer un service YouTubePlayerService utilisant l'API YouTube IFrame Player. Charger dynamiquement le script YouTube API dans index.html ou via le service. Implémenter les méthodes de base : loadVideo(), playVideo(), pauseVideo(), getCurrentTime(), getDuration(). Utiliser les signals Angular pour gérer l'état du lecteur. Gérer les événements onReady, onStateChange. Ajouter la gestion d'erreurs pour les vidéos privées/indisponibles.",
        "testStrategy": "Tester le chargement d'une vidéo YouTube valide, vérifier que les contrôles natifs fonctionnent, tester avec une URL invalide pour confirmer la gestion d'erreur.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Charger dynamiquement l'API YouTube IFrame Player",
            "description": "Implémenter le chargement dynamique du script YouTube API et initialiser l'environnement d'intégration",
            "dependencies": [],
            "details": "Créer une méthode loadYouTubeAPI() qui injecte dynamiquement le script https://www.youtube.com/iframe_api dans le document. Utiliser un Promise pour gérer l'état de chargement et éviter les multiples chargements. Implémenter une variable globale onYouTubeIframeAPIReady pour capturer la callback d'initialisation. Gérer les erreurs de chargement du script et les timeouts.",
            "status": "done",
            "testStrategy": "Vérifier que le script YouTube API se charge correctement, tester les scénarios d'erreur de réseau, valider qu'une seule instance du script est chargée même avec multiples appels"
          },
          {
            "id": 2,
            "title": "Créer le service YouTubePlayerService avec architecture signals",
            "description": "Développer le service principal avec la gestion d'état basée sur les signals Angular",
            "dependencies": [
              "2.1"
            ],
            "details": "Créer YouTubePlayerService injectable avec signals pour : playerState (unloaded/loading/ready/playing/paused/error), currentVideo (videoId, title, duration), playerInstance. Implémenter le pattern de service avec computed signals pour les états dérivés. Utiliser takeUntilDestroyed pour la gestion automatique des subscriptions. Initialiser le service avec la méthode d'injection moderne inject().",
            "status": "done",
            "testStrategy": "Tester l'initialisation du service, vérifier les states des signals, valider la gestion mémoire avec takeUntilDestroyed"
          },
          {
            "id": 3,
            "title": "Implémenter les méthodes de contrôle vidéo de base",
            "description": "Développer les méthodes fondamentales de contrôle du lecteur YouTube",
            "dependencies": [
              "2.2"
            ],
            "details": "Implémenter loadVideo(videoId: string) avec extraction d'ID depuis URL complète, playVideo(), pauseVideo(), getCurrentTime(), getDuration(), seekTo(seconds: number). Chaque méthode doit vérifier l'état du player avant exécution. Utiliser des Promises pour les opérations asynchrones. Intégrer la mise à jour des signals correspondants après chaque opération.",
            "status": "done",
            "testStrategy": "Tester chaque méthode individuellement, vérifier les retours d'erreur pour player non initialisé, valider la synchronisation des signals avec l'état réel du player"
          },
          {
            "id": 4,
            "title": "Gérer les événements YouTube Player (onReady, onStateChange)",
            "description": "Implémenter la gestion des événements natifs du lecteur YouTube et synchroniser avec les signals",
            "dependencies": [
              "2.3"
            ],
            "details": "Créer les callbacks onPlayerReady() et onPlayerStateChange() pour capturer les événements YouTube. Mapper les états YouTube (YT.PlayerState) vers les signals internes. Émettre des events personnalisés pour les composants externes. Implémenter onPlayerError() pour capturer les erreurs de lecture. Synchroniser automatiquement currentTime via interval quand en lecture.",
            "status": "done",
            "testStrategy": "Tester les transitions d'état (loading->ready->playing->paused), vérifier la synchronisation temps réel, valider la capture d'événements d'erreur"
          },
          {
            "id": 5,
            "title": "Implémenter la gestion d'erreurs pour vidéos indisponibles",
            "description": "Développer un système robuste de gestion des erreurs pour les cas d'échec de chargement vidéo",
            "dependencies": [
              "2.4"
            ],
            "details": "Créer un enum YouTubeError pour typer les erreurs (VIDEO_NOT_FOUND, PRIVATE_VIDEO, REGION_BLOCKED, etc.). Implémenter handlePlayerError() avec mapping des codes d'erreur YouTube vers messages utilisateur français. Utiliser un signal errorState pour exposer l'état d'erreur aux composants. Ajouter retry mechanism avec backoff exponentiel pour erreurs réseau. Logger les erreurs pour debug.",
            "status": "done",
            "testStrategy": "Tester avec vidéo inexistante, vidéo privée, vidéo géo-bloquée, vérifier les messages d'erreur français, valider le système de retry"
          },
          {
            "id": 6,
            "title": "Chargement dynamique du script YouTube IFrame API",
            "description": "Configurer le chargement dynamique du script YouTube IFrame API dans l'application Angular",
            "dependencies": [],
            "details": "Créer une fonction utilitaire pour charger dynamiquement le script YouTube IFrame API (https://www.youtube.com/iframe_api). Implémenter une vérification pour éviter le double chargement. Gérer la promesse de chargement avec resolve/reject. Ajouter la fonction dans un service ou directement dans YouTubePlayerService. S'assurer que window.onYouTubeIframeAPIReady est correctement configurée.",
            "status": "done",
            "testStrategy": "Vérifier que le script se charge une seule fois, tester que l'API est disponible après chargement, valider le callback onYouTubeIframeAPIReady"
          },
          {
            "id": 7,
            "title": "Création du service YouTubePlayerService avec signals",
            "description": "Développer le service principal pour encapsuler l'API YouTube IFrame Player avec la gestion d'état par signals",
            "dependencies": [
              "2.6"
            ],
            "details": "Créer YouTubePlayerService injectable avec providedIn: 'root'. Définir les signals : playerState (loading, ready, playing, paused, error), videoId, currentTime, duration, isLoaded. Créer les interfaces TypeScript pour les événements YouTube. Implémenter la méthode initializePlayer() qui instancie YT.Player. Utiliser takeUntilDestroyed pour la gestion du cycle de vie. Ajouter les types YouTube dans un fichier de déclarations.",
            "status": "done",
            "testStrategy": "Vérifier l'injection du service, tester l'initialisation du player, valider que les signals se mettent à jour correctement"
          },
          {
            "id": 8,
            "title": "Implémentation des méthodes de contrôle vidéo de base",
            "description": "Ajouter les méthodes essentielles pour contrôler la lecture vidéo via l'API YouTube",
            "dependencies": [
              "2.7"
            ],
            "details": "Implémenter dans YouTubePlayerService les méthodes : loadVideo(videoId: string), playVideo(), pauseVideo(), getCurrentTime(): number, getDuration(): number, seekTo(seconds: number). Chaque méthode doit vérifier que le player est prêt avant exécution. Gérer les erreurs avec try/catch. Mettre à jour les signals correspondants après chaque action. Ajouter des guards pour vérifier l'état du player.",
            "status": "done",
            "testStrategy": "Tester chaque méthode individuellement, vérifier que getCurrentTime et getDuration retournent des valeurs correctes, valider la gestion d'erreur"
          },
          {
            "id": 9,
            "title": "Gestion des événements YouTube Player (onReady, onStateChange)",
            "description": "Implémenter la gestion des événements du lecteur YouTube pour synchroniser l'état de l'application",
            "dependencies": [
              "2.8"
            ],
            "details": "Configurer les event handlers onReady et onStateChange lors de l'initialisation du player. Dans onReady, mettre à jour le signal playerState à 'ready' et récupérer la durée. Dans onStateChange, mapper les états YouTube (PLAYING, PAUSED, ENDED, etc.) vers les signals internes. Implémenter un interval pour mettre à jour currentTime pendant la lecture. Gérer l'événement onError pour les erreurs de lecture.",
            "status": "done",
            "testStrategy": "Vérifier que onReady se déclenche, tester les changements d'état lors de play/pause, valider la mise à jour du temps courant"
          },
          {
            "id": 10,
            "title": "Gestion d'erreurs pour vidéos privées et indisponibles",
            "description": "Implémenter la gestion complète des erreurs YouTube avec feedback utilisateur approprié",
            "dependencies": [
              "2.9"
            ],
            "details": "Étendre la gestion d'erreurs dans onError pour identifier les types d'erreurs YouTube : vidéo privée (code 101), vidéo supprimée (code 100), géo-blocage (code 150), vidéo non trouvée (code 5). Créer un signal errorMessage pour stocker les messages d'erreur localisés en français. Implémenter clearError() pour réinitialiser l'état d'erreur. Ajouter des méthodes helper pour détecter si une vidéo est disponible. Prévoir un fallback pour les erreurs non identifiées.",
            "status": "done",
            "testStrategy": "Tester avec des URLs de vidéos privées, supprimées, géo-bloquées, vérifier l'affichage des messages d'erreur appropriés, valider la remise à zéro des erreurs"
          }
        ]
      },
      {
        "id": 3,
        "title": "Composant de saisie d'URL YouTube avec validation",
        "description": "Créer le composant pour saisir et valider les URLs YouTube avec auto-focus et feedback utilisateur",
        "details": "Créer UrlInputComponent avec un formulaire réactif Angular. Implémenter la validation d'URL YouTube avec regex pour détecter les formats youtube.com/watch?v= et youtu.be/. Ajouter auto-focus avec ViewChild et ngAfterViewInit. Créer un placeholder avec exemple d'URL. Utiliser debounceTime pour éviter les validations excessives. Intégrer avec YouTubePlayerService pour charger automatiquement les vidéos valides. Afficher des messages d'erreur clairs pour les URLs invalides.",
        "testStrategy": "Tester avec différents formats d'URLs YouTube (youtube.com, youtu.be, avec/sans paramètres), vérifier l'auto-focus, valider les messages d'erreur pour URLs invalides.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Composant lecteur vidéo avec contrôles natifs",
        "description": "Créer le composant pour afficher la vidéo YouTube avec l'API IFrame et les contrôles natifs",
        "details": "Créer VideoPlayerComponent qui utilise YouTubePlayerService. Implémenter l'affichage du lecteur IFrame avec les contrôles natifs YouTube activés (controls: 1). Gérer les états de chargement, erreur, et lecture. Utiliser signals pour réagir aux changements d'état. Implémenter la communication bidirectionnelle avec le service pour exposer les méthodes nécessaires (getCurrentTime, getDuration, etc.). Responsive design pour différentes tailles d'écran.",
        "testStrategy": "Vérifier l'affichage correct de la vidéo, tester les contrôles natifs (play, pause, volume, plein écran), valider la responsivité sur mobile/desktop.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure de base du VideoPlayerComponent",
            "description": "Générer et configurer le composant VideoPlayer avec l'architecture de base et l'injection du YouTubePlayerService",
            "dependencies": [],
            "details": "Créer VideoPlayerComponent dans features/video-player/ui/video-player/ avec ng generate. Configurer l'injection du YouTubePlayerService via inject(). Définir les signals de base pour l'état du lecteur (isLoading, hasError, currentVideoId). Créer le template HTML de base avec un conteneur pour le lecteur IFrame. Configurer les styles SCSS responsive avec des breakpoints mobile/desktop.",
            "status": "done",
            "testStrategy": "Vérifier que le composant se compile correctement et s'affiche sans erreur dans l'application"
          },
          {
            "id": 2,
            "title": "Implémenter l'affichage du lecteur IFrame YouTube",
            "description": "Intégrer l'API YouTube IFrame Player dans le composant avec les contrôles natifs activés",
            "dependencies": [
              "4.1"
            ],
            "details": "Ajouter un div conteneur avec un ID unique pour le lecteur YouTube. Utiliser ViewChild pour référencer l'élément DOM. Dans ngAfterViewInit, appeler le service pour initialiser le lecteur avec les paramètres : controls: 1, showinfo: 0, rel: 0. Configurer la taille responsive du lecteur (16:9 ratio). Gérer les événements onReady du lecteur pour confirmer l'initialisation.",
            "status": "done",
            "testStrategy": "Tester l'affichage du lecteur avec une URL valide, vérifier que les contrôles natifs (play, pause, volume, plein écran) sont visibles et fonctionnels"
          },
          {
            "id": 3,
            "title": "Gérer les états de chargement et d'erreur",
            "description": "Implémenter la gestion des différents états du lecteur (chargement, erreur, prêt) avec feedback utilisateur",
            "dependencies": [
              "4.2"
            ],
            "details": "Créer des signals pour isLoading, hasError, errorMessage. Écouter les événements onStateChange du lecteur pour détecter les états BUFFERING, PLAYING, PAUSED, ENDED. Afficher un spinner de chargement pendant le buffering. Créer des messages d'erreur pour vidéos privées, indisponibles, ou géo-bloquées. Implémenter un mécanisme de retry pour les erreurs temporaires.",
            "status": "done",
            "testStrategy": "Tester avec une vidéo valide, une vidéo privée, et une URL inexistante pour valider tous les cas d'erreur et états de chargement"
          },
          {
            "id": 4,
            "title": "Implémenter la communication bidirectionnelle avec YouTubePlayerService",
            "description": "Exposer les méthodes du lecteur et synchroniser l'état entre le composant et le service",
            "dependencies": [
              "4.3"
            ],
            "details": "Créer des méthodes publiques : getCurrentTime(), getDuration(), seekTo(), getVideoData(). Utiliser des signals computed pour exposer l'état du lecteur (currentTime, duration, playbackState). Implémenter un système d'événements pour notifier les changements d'état au service parent. Ajouter des méthodes pour contrôler la lecture : play(), pause(), stop().",
            "status": "done",
            "testStrategy": "Vérifier que getCurrentTime() retourne la position correcte, tester seekTo() pour naviguer dans la vidéo, valider la synchronisation des états"
          },
          {
            "id": 5,
            "title": "Optimiser la responsivité et finaliser l'interface",
            "description": "Perfectionner le design responsive et l'intégration visuelle du composant dans l'application",
            "dependencies": [
              "4.4"
            ],
            "details": "Implémenter CSS Grid/Flexbox pour un layout responsive optimal. Ajouter des media queries pour mobile (< 768px), tablette (768px-1024px), et desktop (> 1024px). Configurer l'aspect ratio 16:9 avec CSS aspect-ratio ou padding-bottom technique. Ajouter des styles pour les états de chargement et d'erreur. Optimiser les performances avec OnPush change detection strategy.",
            "status": "done",
            "testStrategy": "Tester sur différentes tailles d'écran, vérifier l'aspect ratio en mode portrait/paysage, valider l'accessibilité avec navigation clavier"
          }
        ]
      },
      {
        "id": 5,
        "title": "Service de gestion des boucles temporelles",
        "description": "Créer un service pour gérer la logique de boucle avec start/end times et la répétition automatique",
        "details": "Créer LoopService avec signals pour gérer startTime, endTime, isLoopActive. Implémenter la logique de surveillance temporelle avec interval pour vérifier la position courante. Quand currentTime >= endTime, rediriger vers startTime. Méthodes : setStartTime(), setEndTime(), toggleLoop(), getCurrentLoop(). Utiliser takeUntilDestroyed pour nettoyer les intervalles. Intégrer avec YouTubePlayerService pour contrôler la position de la vidéo. Gérer un seul loop actif à la fois (V1).",
        "testStrategy": "Tester la création d'une boucle avec start/end, vérifier que la vidéo redémarre automatiquement à startTime après avoir atteint endTime, valider l'activation/désactivation de la boucle.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Interface timeline interactive avec poignées start/end",
        "description": "Créer un composant timeline avec deux poignées draggables pour définir visuellement les bornes de boucle",
        "details": "Créer TimelineComponent avec une barre de progression visuelle. Implémenter deux poignées draggables (start/end) avec HTML5 drag & drop ou mouse events. Afficher le temps au-dessus de chaque poignée pendant le drag. Zone colorée entre start et end pour visualiser la boucle. Synchroniser avec LoopService pour mettre à jour les temps. Responsive avec touch events pour mobile. Contraintes : startTime < endTime, bornes dans la durée de la vidéo.",
        "testStrategy": "Tester le drag des poignées, vérifier l'affichage des temps, valider la zone colorée, tester sur écran tactile, vérifier les contraintes de validation.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure du composant TimelineComponent",
            "description": "Générer le composant TimelineComponent avec sa structure de base, l'intégrer dans l'architecture existante et préparer l'injection du LoopService",
            "dependencies": [],
            "details": "Créer TimelineComponent dans src/app/features/video-controls/ui/timeline/ en suivant les conventions du projet. Générer les fichiers component.ts, component.html, component.scss avec architecture standalone. Ajouter l'injection du LoopService et YouTubePlayerService. Créer le fichier index.ts pour barrel export. Mettre en place les signals de base pour startTime, endTime, duration et isActive.",
            "status": "done",
            "testStrategy": "Vérifier la génération correcte du composant, l'injection des services, la compilation sans erreurs et l'affichage de base dans l'interface"
          },
          {
            "id": 2,
            "title": "Implémenter la barre de progression visuelle avec zone colorée",
            "description": "Créer l'interface visuelle de la timeline avec une barre de progression et zone colorée entre les bornes start/end",
            "dependencies": [
              "6.1"
            ],
            "details": "Créer le template HTML avec une barre de progression SVG ou Canvas. Implémenter l'affichage de la position courante de la vidéo. Ajouter la zone colorée entre startTime et endTime. Utiliser les variables CSS du thème existant pour maintenir la cohérence visuelle. Synchroniser l'affichage avec la duration de la vidéo du YouTubePlayerService. Assurer la responsivité sur tous les breakpoints.",
            "status": "done",
            "testStrategy": "Valider l'affichage de la barre de progression, vérifier la zone colorée entre les bornes, tester la responsivité sur mobile/tablet/desktop"
          },
          {
            "id": 3,
            "title": "Développer les poignées draggables start et end",
            "description": "Implémenter deux poignées interactives pour définir les bornes de boucle avec drag and drop",
            "dependencies": [
              "6.2"
            ],
            "details": "Créer deux éléments draggables (poignées start/end) positionnés sur la timeline. Implémenter les event listeners pour mousedown, mousemove, mouseup. Gérer les contraintes : startTime < endTime, bornes dans [0, duration]. Synchroniser les changements avec le LoopService via setStartTime() et setEndTime(). Ajouter des styles visuels distincts pour chaque poignée. Implémenter le feedback visuel pendant le drag (cursor, hover states).",
            "status": "done",
            "testStrategy": "Tester le drag des poignées, vérifier les contraintes de validation, valider la synchronisation avec LoopService, contrôler les feedbacks visuels"
          },
          {
            "id": 4,
            "title": "Ajouter l'affichage du temps au-dessus des poignées",
            "description": "Implémenter l'affichage dynamique du temps pendant le drag des poignées avec formatage approprié",
            "dependencies": [
              "6.3"
            ],
            "details": "Créer des tooltips ou overlays qui affichent le temps (MM:SS format) au-dessus de chaque poignée. Afficher les temps pendant le drag et au survol. Implémenter une fonction de formatage du temps (secondes vers MM:SS). Positionner dynamiquement les affichages selon la position des poignées. Gérer la visibilité et les transitions CSS. Assurer la lisibilité avec les contrastes appropriés selon le thème actuel.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage des temps pendant le drag, valider le formatage MM:SS, tester la visibilité et positionnement sur différentes tailles d'écran"
          },
          {
            "id": 5,
            "title": "Implémenter le support tactile et finaliser l'intégration",
            "description": "Ajouter le support des événements tactiles pour mobile et intégrer le TimelineComponent dans l'interface principale",
            "dependencies": [
              "6.4"
            ],
            "details": "Ajouter les event listeners pour touch events (touchstart, touchmove, touchend). Adapter les calculs de position pour les interactions tactiles. Gérer les spécificités mobile (touch target size minimum 44px). Intégrer le TimelineComponent dans app-main.component.html en remplaçant le commentaire. Appliquer les styles timeline-container existants. Tester la synchronisation complète avec LoopService et YouTubePlayerService. Valider l'expérience utilisateur sur tous les appareils.",
            "status": "done",
            "testStrategy": "Tester les interactions tactiles sur mobile/tablette, vérifier l'intégration dans l'interface principale, valider la synchronisation complète avec les services, contrôler l'ergonomie sur tous les breakpoints"
          }
        ]
      },
      {
        "id": 7,
        "title": "Boutons de contrôle rapide pour la boucle",
        "description": "Implémenter les boutons 'Set Start', 'Set End' et 'Play/Stop Loop' avec indicateurs visuels et contrôle automatique de la position de lecture",
        "details": "Créer LoopControlsComponent avec trois boutons principaux : 'Set Start' (définit startTime à la position courante ET repositionne automatiquement la vidéo sur cette position), 'Set End' (définit endTime à la position courante), 'Toggle Loop' (active/désactive la boucle). NOUVEAU : Le bouton play démarre la lecture depuis startTime et boucle automatiquement entre start et end définis par Set Start/Set End. Design des boutons discret et élégant qui s'intègre parfaitement dans la page existante et au workflow avec la timeline. Boutons tactiles ≥44px selon les guidelines. Intégrer avec LoopService et YouTubePlayerService. Feedback immédiat sur les actions utilisateur.",
        "testStrategy": "Tester chaque bouton individuellement, NOUVEAU : valider que 'Set Start' repositionne automatiquement la vidéo, tester que play démarre depuis startTime et boucle automatiquement, vérifier que 'Set Start/End' utilisent la position courante, valider l'indicateur visuel de boucle, tester la taille tactile des boutons, valider l'intégration design avec la timeline existante.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le composant LoopControlsComponent avec structure de base",
            "description": "Créer le composant standalone LoopControlsComponent avec la structure HTML et SCSS de base pour les trois boutons de contrôle rapide",
            "dependencies": [],
            "details": "Générer le composant avec ng generate dans features/loop/ui/loop-controls. Créer la structure HTML avec trois boutons : 'Set Start', 'Set End' et 'Toggle Loop'. Ajouter les styles SCSS de base avec tailles tactiles minimum 44px selon les guidelines d'accessibilité. Implémenter le design discret et élégant qui s'intègre avec la page existante. Utiliser des icônes appropriées pour chaque bouton.",
            "status": "done",
            "testStrategy": "Vérifier que le composant se compile et s'affiche correctement avec les trois boutons visibles et correctement stylisés"
          },
          {
            "id": 2,
            "title": "Intégrer LoopControlsComponent avec les services existants",
            "description": "Injecter LoopService et YouTubePlayerService dans le composant et créer les méthodes de base pour chaque bouton",
            "dependencies": [
              "7.1"
            ],
            "details": "Utiliser la fonction inject() pour injecter LoopService et YouTubePlayerService. Créer les méthodes setStartTime(), setEndTime() et toggleLoop(). Implémenter les signals nécessaires pour réagir aux changements d'état. Créer les event handlers pour les clics des boutons. Préparer la structure pour la logique de repositionnement automatique.",
            "status": "done",
            "testStrategy": "Tester l'injection des services et vérifier que les méthodes sont appelées lors des clics sur les boutons"
          },
          {
            "id": 3,
            "title": "Implémenter la fonctionnalité 'Set Start' avec repositionnement automatique",
            "description": "Développer la logique du bouton 'Set Start' qui définit le startTime à la position courante ET repositionne automatiquement la vidéo sur cette position",
            "dependencies": [
              "7.2"
            ],
            "details": "Implémenter setStartTime() pour récupérer la position courante via YouTubePlayerService.getCurrentTime(), mettre à jour loopService.startTime, puis immédiatement repositionner la vidéo sur cette position avec YouTubePlayerService.seekTo(). Ajouter feedback visuel immédiat pour confirmer l'action. Gérer les cas d'erreur si la vidéo n'est pas prête.",
            "status": "done",
            "testStrategy": "Valider que Set Start récupère la position courante, met à jour le startTime dans LoopService et repositionne automatiquement la vidéo à cette position"
          },
          {
            "id": 4,
            "title": "Implémenter la fonctionnalité 'Set End' et 'Toggle Loop'",
            "description": "Développer la logique des boutons 'Set End' et 'Toggle Loop' avec indicateurs visuels d'état",
            "dependencies": [
              "7.3"
            ],
            "details": "Implémenter setEndTime() pour définir endTime à la position courante via YouTubePlayerService.getCurrentTime(). Développer toggleLoop() pour activer/désactiver la boucle via loopService.toggleLoop(). Ajouter indicateurs visuels : état actif/inactif du bouton Toggle Loop, feedback temporaire pour Set End. Implémenter la logique pour que Toggle Loop démarre la lecture depuis startTime quand activé.",
            "status": "done",
            "testStrategy": "Tester Set End avec la position courante, valider Toggle Loop pour activer/désactiver la boucle, vérifier les indicateurs visuels d'état"
          },
          {
            "id": 5,
            "title": "Finaliser l'intégration et la logique de lecture automatique",
            "description": "Compléter l'intégration avec la timeline et implémenter la logique de lecture automatique depuis startTime avec bouclage automatique",
            "dependencies": [
              "7.4"
            ],
            "details": "Intégrer LoopControlsComponent dans MainPlayerComponent. Synchroniser avec TimelineComponent pour refléter les changements de bornes. Implémenter la logique pour que le bouton play/toggle démarre la lecture depuis startTime et boucle automatiquement entre start et end. Ajouter la gestion des états : disabled quand pas de vidéo chargée, feedback sur les actions utilisateur. Optimiser les performances et nettoyer les listeners.",
            "status": "done",
            "testStrategy": "Tester l'intégration complète : vérifier que play démarre depuis startTime et boucle automatiquement, valider la synchronisation avec la timeline, tester tous les cas d'usage bout-en-bout"
          }
        ]
      },
      {
        "id": 8,
        "title": "Contrôle de vitesse de lecture avec presets",
        "description": "Implémenter les contrôles de vitesse avec boutons presets (0.5x, 0.75x, 1x) et menu déroulant pour options avancées",
        "details": "Créer SpeedControlComponent avec trois boutons presets pour les vitesses courantes (0.5x, 0.75x, 1x). Ajouter un dropdown/select pour vitesses supplémentaires (0.25x, 0.375x, 1.25x, 1.5x, 1.75x, 2x). Afficher la vitesse courante avec un indicateur visuel. Utiliser l'API YouTube setPlaybackRate(). Persister la vitesse sélectionnée dans localStorage. Intégrer avec YouTubePlayerService pour synchroniser l'état.",
        "testStrategy": "Tester chaque preset de vitesse, vérifier le menu déroulant, valider l'affichage de la vitesse courante, tester la persistance localStorage.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le composant SpeedControlComponent avec structure de base",
            "description": "Générer et configurer le composant SpeedControlComponent avec la structure de base, les imports nécessaires et l'intégration dans l'application",
            "dependencies": [],
            "details": "Utiliser Angular CLI pour générer le composant dans features/player/ui/speed-control. Créer la structure HTML de base avec conteneur pour boutons presets et dropdown. Configurer les imports standalone nécessaires (CommonModule, FormsModule). Ajouter les styles SCSS de base. Créer l'interface TypeScript pour les types de vitesse. Intégrer le composant dans PlayerControlsComponent ou directement dans AppComponent.",
            "status": "done",
            "testStrategy": "Vérifier que le composant s'affiche correctement dans l'application et que la structure HTML est bien formée"
          },
          {
            "id": 2,
            "title": "Implémenter les boutons presets de vitesse (0.5x, 0.75x, 1x)",
            "description": "Créer les trois boutons principaux pour les vitesses courantes avec gestion des clics et état actif",
            "dependencies": [
              "8.1"
            ],
            "details": "Créer un tableau des vitesses presets : [0.5, 0.75, 1.0]. Implémenter les boutons avec ngFor et gestion du clic via (click)='setSpeed(speed)'. Ajouter une classe CSS 'active' pour le bouton correspondant à la vitesse courante. Utiliser un signal currentSpeed pour gérer l'état. Implémenter la méthode setSpeed() qui appellera YouTubePlayerService.setPlaybackRate(). Styliser les boutons avec styles distinctifs et états hover/active.",
            "status": "done",
            "testStrategy": "Cliquer sur chaque bouton preset et vérifier que la vitesse de lecture change, valider l'affichage visuel de l'état actif"
          },
          {
            "id": 3,
            "title": "Développer le menu déroulant pour vitesses avancées",
            "description": "Implémenter un dropdown/select avec les vitesses supplémentaires et gestion de la sélection",
            "dependencies": [
              "8.2"
            ],
            "details": "Créer un select HTML avec les options : 0.25x, 0.375x, 1.25x, 1.5x, 1.75x, 2x. Utiliser ngModel pour la liaison bidirectionnelle avec currentSpeed signal. Implémenter (change)='onSpeedChange($event)' pour gérer la sélection. Styliser le dropdown pour correspondre au design de l'application. Ajouter une option par défaut 'Autres vitesses...' quand aucune vitesse avancée n'est sélectionnée. Synchroniser avec les boutons presets pour désactiver le dropdown quand un preset est actif.",
            "status": "done",
            "testStrategy": "Sélectionner différentes vitesses dans le dropdown et vérifier que la lecture change, tester la synchronisation avec les boutons presets"
          },
          {
            "id": 4,
            "title": "Intégrer avec YouTubePlayerService et ajouter l'indicateur visuel",
            "description": "Connecter le composant avec YouTubePlayerService pour contrôler la vitesse et afficher l'indicateur de vitesse courante",
            "dependencies": [
              "8.2",
              "8.3"
            ],
            "details": "Injecter YouTubePlayerService dans le composant. Implémenter la méthode setPlaybackRate() du service si elle n'existe pas encore. Créer un signal computed() pour afficher la vitesse courante avec format 'Xx' (ex: '0.75x'). Ajouter un indicateur visuel (badge ou texte) montrant la vitesse active près du lecteur. Gérer les erreurs si setPlaybackRate() échoue (certaines vitesses peuvent ne pas être supportées). Écouter les changements d'état du player pour synchroniser la vitesse affichée.",
            "status": "done",
            "testStrategy": "Vérifier que les changements de vitesse via l'interface affectent réellement la lecture YouTube, valider l'affichage correct de l'indicateur de vitesse"
          },
          {
            "id": 5,
            "title": "Implémenter la persistance localStorage et finaliser l'intégration",
            "description": "Ajouter la persistance de la vitesse sélectionnée et finaliser l'intégration complète avec l'application",
            "dependencies": [
              "8.4"
            ],
            "details": "Implémenter la sauvegarde de currentSpeed dans localStorage avec clé 'youtube-looper-speed'. Charger la vitesse sauvegardée au démarrage du composant avec ngOnInit(). Appliquer automatiquement la vitesse restaurée lors du chargement d'une nouvelle vidéo. Gérer les cas d'erreur (localStorage indisponible, valeur corrompue) avec fallback sur vitesse 1x. Ajouter des animations CSS pour les transitions de vitesse. Optimiser les performances avec debounce si nécessaire. Effectuer les tests finaux d'intégration avec tous les composants.",
            "status": "done",
            "testStrategy": "Changer la vitesse, recharger l'application et vérifier que la vitesse est restaurée, tester avec localStorage désactivé, valider l'intégration complète avec les autres contrôles"
          }
        ]
      },
      {
        "id": 9,
        "title": "Persistance localStorage et gestion des préférences",
        "description": "Implémenter la sauvegarde locale des boucles, vitesse, et URL pour permettre la restauration des sessions",
        "details": "Créer StorageService pour gérer localStorage. Sauvegarder : URL courante, startTime/endTime de la boucle, vitesse de lecture, état de la boucle (active/inactive). Implémenter auto-save lors des changements d'état. Ajouter une méthode de restauration au démarrage de l'application. Gérer les cas d'erreur (localStorage indisponible, données corrompues). Nettoyer les anciennes données si nécessaire. Utiliser JSON.stringify/parse pour les objets complexes.",
        "testStrategy": "Tester la sauvegarde automatique des paramètres, vérifier la restauration au rechargement de la page, valider la gestion des erreurs localStorage, tester avec plusieurs vidéos.",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Interface responsive et optimisations d'accessibilité",
        "description": "Finaliser le design responsive mobile-first et implémenter les fonctionnalités d'accessibilité",
        "details": "Implémenter CSS Grid/Flexbox pour layout responsive. Breakpoints : mobile (<768px), tablet (768px-1024px), desktop (>1024px). Optimiser pour orientation paysage sur tablette. Ajouter navigation clavier (tab index, focus visible). Implémenter couleurs contrastées selon WCAG AA. Ajouter aria-labels pour tous les contrôles. Tailles tactiles minimum 44px. Tester avec screen readers. Ajouter un toggle dark/light mode pour améliorer la lisibilité.",
        "testStrategy": "Tester sur différents appareils (mobile, tablette, desktop), valider la navigation clavier, vérifier les contrastes de couleur, tester avec lecteur d'écran, valider les orientations portrait/paysage.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Optimiser le système de responsive design avec CSS Grid/Flexbox",
            "description": "Réviser et unifier l'architecture responsive mobile-first en consolidant les breakpoints (<768px, 768px-1024px, >1024px) avec CSS Grid pour les layouts principaux et Flexbox pour les composants individuels.",
            "dependencies": [],
            "details": "Auditer le code SCSS existant dans tous les composants pour identifier les incohérences dans les breakpoints. Consolider les variables CSS pour les breakpoints dans styles.scss. Optimiser app-main.component.scss pour garantir que CSS Grid fonctionne parfaitement sur tous les breakpoints. Implémenter des containers Flexbox cohérents pour timeline, loop-controls et speed-control. Gérer spécifiquement l'orientation landscape sur tablette avec des media queries appropriées.",
            "status": "done",
            "testStrategy": "Tester sur différents appareils (mobile <768px, tablet 768px-1024px, desktop >1024px), valider l'orientation portrait/paysage sur tablette, vérifier que tous les composants utilisent les mêmes breakpoints de manière cohérente."
          },
          {
            "id": 2,
            "title": "Implémenter la navigation clavier et focus management",
            "description": "Ajouter un système complet de navigation au clavier avec tab index, focus visible et indicateurs visuels pour tous les contrôles interactifs.",
            "dependencies": [
              "10.1"
            ],
            "details": "Ajouter tabindex sur tous les éléments interactifs (boutons, input URL, timeline handles, contrôles vitesse). Implémenter focus-visible avec outline personnalisé utilisant var(--primary-color) pour maintenir la cohérence visuelle. Créer un ordre de tabulation logique : URL input → Load button → Timeline handles → Loop controls → Speed controls → Theme toggle. Ajouter des indicateurs de focus keyboard-only (pas de focus au clic souris). Gérer le focus trap pour les interactions timeline drag.",
            "status": "done",
            "testStrategy": "Tester la navigation complète au clavier avec Tab/Shift+Tab, vérifier que tous les éléments sont accessibles au clavier, valider les indicateurs focus visibles, tester le focus trap sur la timeline."
          },
          {
            "id": 3,
            "title": "Implémenter les couleurs contrastées selon WCAG AA",
            "description": "Réviser le système de couleurs existant pour garantir un contraste minimum 4.5:1 selon les standards WCAG AA et optimiser la lisibilité.",
            "dependencies": [
              "10.2"
            ],
            "details": "Auditer tous les contrastes couleur/fond dans les thèmes dark et light actuels avec des outils de validation WCAG. Ajuster les variables CSS dans styles.scss pour atteindre le ratio 4.5:1 minimum. Réviser particulièrement --text-secondary, --text-muted pour les labels et textes d'aide. Assurer que les états disabled, focus, hover maintiennent les contrastes requis. Optimiser la lisibilité des informations critiques (temps de boucle, messages d'erreur, états des boutons).",
            "status": "done",
            "testStrategy": "Utiliser des outils de validation de contraste (WebAIM, axe), tester la lisibilité dans différentes conditions d'éclairage, valider tous les états interactifs (hover, focus, disabled)."
          },
          {
            "id": 4,
            "title": "Ajouter aria-labels et améliorer la sémantique HTML pour screen readers",
            "description": "Enrichir tous les composants avec des aria-labels appropriés, role attributes et descriptions sémantiques pour optimiser l'expérience avec les lecteurs d'écran.",
            "dependencies": [
              "10.3"
            ],
            "details": "Ajouter aria-label sur tous les boutons sans texte explicite (timeline handles, clear button, theme toggle). Implémenter aria-describedby pour les relations input/error messages. Ajouter role='slider' et aria-valuemin/max/now sur les timeline handles. Enrichir les messages d'état avec aria-live pour les changements de loop status, loading states. Ajouter aria-expanded sur les composants avec états (speed control dropdown). Créer des descriptions contextuelles avec sr-only classes pour navigation complexe.",
            "status": "done",
            "testStrategy": "Tester avec NVDA, JAWS ou VoiceOver, vérifier que toutes les actions sont annoncées correctement, valider la navigation logique avec screen reader, tester les descriptions d'état et changements dynamiques."
          },
          {
            "id": 5,
            "title": "Optimiser les tailles tactiles et interactions touch pour mobile",
            "description": "Garantir une taille minimum de 44px pour tous les éléments interactifs et optimiser les interactions touch, particulièrement pour les timeline handles.",
            "dependencies": [
              "10.1",
              "10.4"
            ],
            "details": "Auditer toutes les tailles d'éléments interactifs et appliquer 44x44px minimum. Optimiser spécifiquement timeline handles pour le touch (augmenter zone de touch sans affecter le visuel). Ajouter des zones de touch étendues avec ::before pseudo-elements si nécessaire. Améliorer les boutons loop-controls et speed-control pour faciliter l'interaction thumb. Implémenter touch feedback (active states) sur mobile. Gérer les conflits entre touch events et drag events sur timeline.",
            "status": "done",
            "testStrategy": "Tester sur dispositifs tactiles réels (smartphone, tablette), valider la facilité d'interaction avec le pouce, mesurer les zones de touch avec outils développeur, tester le drag des timeline handles sur écrans tactiles."
          }
        ]
      },
      {
        "id": 11,
        "title": "Créer le layout principal et composant header avec mode sombre/clair",
        "description": "Développer un gabarit global minimaliste avec header contenant le titre de l'app et toggle dark/light mode, une zone principale pour le contenu, et un footer discret.",
        "details": "Créer MainLayoutComponent avec structure HTML sémantique (header, main, footer). Implémenter HeaderComponent avec titre 'YouTube Looper' et ThemeToggleComponent pour basculer dark/light mode. Créer les variables CSS custom properties dans styles.scss pour les deux thèmes : couleurs primaires, secondaires, backgrounds, textes, bordures. Utiliser CSS Grid pour le layout principal responsive. Header fixe en haut avec flexbox pour titre/toggle alignés. Zone main flexible pour accueillir les futurs composants (URL input, vidéo, contrôles). Footer minimaliste en bas avec liens essentiels. Implémenter ThemeService avec signals pour gérer l'état du thème et persister la préférence dans localStorage. Appliquer les classes CSS dynamiquement selon le thème sélectionné.",
        "testStrategy": "Vérifier l'affichage correct des trois zones (header, main, footer), tester le basculement des thèmes avec changement visuel immédiat, valider la persistance du thème au rechargement, contrôler la responsivité sur mobile/desktop, vérifier que les variables CSS sont correctement appliquées pour chaque thème.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le service ThemeService avec gestion des signaux",
            "description": "Implémenter le service responsable de la gestion du thème (dark/light) avec signals et persistance dans localStorage",
            "dependencies": [],
            "details": "Créer ThemeService dans src/app/core/services/ avec signals pour gérer l'état du thème ('light' | 'dark'). Implémenter toggleTheme(), setTheme(), currentTheme signal en lecture seule. Persister la préférence dans localStorage avec la clé 'theme-preference'. Initialiser avec thème système ou valeur par défaut 'light'. Utiliser inject() et signal() d'Angular. Appliquer les classes CSS dynamiquement sur document.documentElement.",
            "status": "done",
            "testStrategy": "Tester le basculement de thème avec changement immédiat, vérifier la persistance localStorage, contrôler l'initialisation avec thème par défaut et système"
          },
          {
            "id": 2,
            "title": "Définir les variables CSS custom properties pour les thèmes",
            "description": "Créer les variables CSS globales pour les couleurs des thèmes sombre et clair dans styles.scss",
            "dependencies": [
              "11.1"
            ],
            "details": "Dans src/styles.scss, définir les custom properties CSS pour les deux thèmes. Variables pour couleurs primaires, secondaires, backgrounds (principal, secondaire, surfaces), textes (primaire, secondaire, tertiaire), bordures, ombres. Utiliser la structure :root { } pour le thème clair et [data-theme='dark'] { } pour le thème sombre. Couleurs cohérentes et accessibles avec contraste WCAG AA minimum. Prévoir variables pour états hover, focus, active.",
            "status": "done",
            "testStrategy": "Vérifier que les variables CSS sont correctement appliquées selon le thème, contrôler les contrastes d'accessibilité, tester les états interactifs"
          },
          {
            "id": 3,
            "title": "Créer le composant ThemeToggleComponent",
            "description": "Développer le composant bouton pour basculer entre les modes sombre et clair",
            "dependencies": [
              "11.1",
              "11.2"
            ],
            "details": "Créer ThemeToggleComponent dans src/app/shared/ui/theme-toggle/ avec structure organisée (index.ts, .component.ts, .html, .scss). Utiliser ThemeService avec inject(). Template avec bouton et icônes pour soleil/lune. Accessibilité avec aria-label, aria-pressed. Animations CSS smooth pour transition d'icônes. Styles avec variables CSS custom properties. Signal computed pour afficher l'icône selon thème actuel.",
            "status": "done",
            "testStrategy": "Tester le changement visuel d'icône selon le thème, vérifier l'accessibilité (aria-*, navigation clavier), valider les animations de transition"
          },
          {
            "id": 4,
            "title": "Créer le composant HeaderComponent avec titre et toggle thème",
            "description": "Développer le composant header contenant le titre de l'application et le toggle de thème",
            "dependencies": [
              "11.3"
            ],
            "details": "Créer HeaderComponent dans src/app/layout/ui/header/ avec structure organisée. Template avec titre 'YouTube Looper' et ThemeToggleComponent. Utiliser flexbox pour alignement horizontal (titre à gauche, toggle à droite). Header fixe en position sticky ou fixed selon besoins. Responsive avec ajustements mobile. Sémantique HTML correcte avec balises header, h1. Styles avec variables CSS custom properties.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage correct du titre et du toggle, tester la responsivité mobile/desktop, valider la position fixe et l'accessibilité"
          },
          {
            "id": 5,
            "title": "Créer le composant MainLayoutComponent avec structure grid",
            "description": "Développer le layout principal avec header, zone contenu principal et footer en CSS Grid",
            "dependencies": [
              "11.4"
            ],
            "details": "Créer MainLayoutComponent dans src/app/layout/ui/main-layout/ avec structure HTML sémantique (header, main, footer). Utiliser CSS Grid pour layout responsive : header fixe en haut, main flexible au centre, footer en bas. Grid-template-rows avec fr unités. Zone main avec padding et préparation pour futurs composants. Footer discret avec copyright et liens essentiels. Intégrer HeaderComponent. Responsive avec ajustements mobile/tablet.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage correct des trois zones (header, main, footer), tester la responsivité sur mobile/desktop, contrôler que la zone main occupe l'espace disponible"
          },
          {
            "id": 6,
            "title": "Créer le service ThemeService pour la gestion du mode sombre/clair",
            "description": "Développer un service Angular utilisant des signals pour gérer l'état du thème (dark/light) et persister les préférences utilisateur dans localStorage",
            "dependencies": [],
            "details": "Créer ThemeService dans src/app/core/services/ avec signal pour currentTheme ('light' | 'dark'). Implémenter méthodes toggleTheme(), setTheme(), loadTheme() depuis localStorage. Utiliser effect() pour appliquer la classe CSS sur document.body. Initialiser avec la préférence système via window.matchMedia('(prefers-color-scheme: dark)'). Persister automatiquement les changements dans localStorage avec clé 'youtube-looper-theme'.",
            "status": "done",
            "testStrategy": "Tester l'initialisation avec préférence système, vérifier la persistance localStorage, valider l'application des classes CSS sur body"
          },
          {
            "id": 7,
            "title": "Définir les variables CSS et thèmes dans styles.scss",
            "description": "Créer un système de variables CSS custom properties pour supporter les thèmes dark et light avec toutes les couleurs nécessaires",
            "dependencies": [
              "11.6"
            ],
            "details": "Dans src/styles.scss, définir :root avec variables CSS --color-primary, --color-secondary, --color-background, --color-surface, --color-text-primary, --color-text-secondary, --color-border, --color-accent pour le thème light. Créer .dark-theme avec les mêmes variables mais valeurs adaptées au mode sombre. Ajouter reset CSS basique et styles globaux. Utiliser des couleurs accessibles avec contraste suffisant (minimum WCAG AA). Prévoir variables pour les transitions et shadows.",
            "status": "done",
            "testStrategy": "Vérifier que les variables CSS sont bien définies, tester l'application des thèmes en basculant les classes, valider les contrastes d'accessibilité"
          },
          {
            "id": 8,
            "title": "Créer le composant ThemeToggleComponent",
            "description": "Développer un composant toggle switch pour basculer entre les modes sombre et clair avec feedback visuel immédiat",
            "dependencies": [
              "11.6",
              "11.7"
            ],
            "details": "Créer ThemeToggleComponent dans src/app/shared/ui/theme-toggle/ avec template HTML contenant un bouton toggle stylisé. Utiliser inject(ThemeService) pour accéder au service. Implémenter onClick() qui appelle themeService.toggleTheme(). Afficher une icône soleil/lune selon le thème actuel avec computed() signal. Styles SCSS pour switch animé avec transition smooth. Accessible avec rôles ARIA appropriés et support clavier (space/enter).",
            "status": "done",
            "testStrategy": "Tester le basculement visuel immédiat, vérifier l'accessibilité clavier, valider les animations CSS de transition"
          },
          {
            "id": 9,
            "title": "Créer le composant HeaderComponent avec titre et toggle thème",
            "description": "Développer le composant header contenant le titre de l'application et le toggle de thème, avec layout responsive",
            "dependencies": [
              "11.8"
            ],
            "details": "Créer HeaderComponent dans src/app/shared/ui/header/ avec template contenant <header> sémantique. Structure : titre 'YouTube Looper' à gauche, ThemeToggleComponent à droite. Utiliser flexbox pour alignement avec justify-content: space-between. Header fixe en haut (position: fixed, top: 0) avec z-index approprié. Styles responsive : titre plus petit sur mobile, padding adaptatif. Hauteur fixe (ex: 60px) pour que le main content puisse s'adapter.",
            "status": "done",
            "testStrategy": "Vérifier l'affichage titre/toggle, tester la responsivité mobile/desktop, valider la position fixe et l'alignement"
          },
          {
            "id": 10,
            "title": "Créer le MainLayoutComponent avec structure Grid responsive",
            "description": "Développer le composant layout principal utilisant CSS Grid pour organiser header, main et footer de façon responsive",
            "dependencies": [
              "11.9"
            ],
            "details": "Créer MainLayoutComponent dans src/app/core/layout/ avec template contenant HeaderComponent, <main> avec router-outlet, et <footer> minimaliste. Utiliser CSS Grid : grid-template-rows: auto 1fr auto pour header/main/footer. Header fixe compensé par padding-top sur main. Main zone flexible pour contenu futur. Footer discret avec liens copyright et version. Responsive : adapter grid sur mobile. Classes CSS utilisant les variables de thème définies. Intégrer ng-content ou router-outlet selon besoins.",
            "status": "done",
            "testStrategy": "Vérifier la structure Grid responsive, tester l'affichage des trois zones, valider l'adaptation mobile et l'application des thèmes"
          }
        ]
      },
      {
        "id": 12,
        "title": "Interface utilisateur principale intégrée avec layout responsive",
        "description": "Créer l'interface utilisateur définitive en intégrant UrlInputComponent et VideoPlayerComponent dans un layout responsive cohérent avec zones préparées pour les futurs composants.",
        "details": "Créer AppMainComponent qui remplace le composant de test actuel en intégrant UrlInputComponent et VideoPlayerComponent existants. Implémenter un design system modulaire avec CSS Grid pour organiser les zones : zone de saisie URL en haut, zone player principale au centre, zone contrôles vide préparée pour les futurs composants (timeline, boucles, vitesse), et footer discret. Utiliser CSS custom properties pour maintenir la cohérence avec le thème dark/light existant. Implémenter une architecture responsive mobile-first avec breakpoints : mobile (<768px), tablet (768px-1024px), desktop (>1024px). Créer des container classes réutilisables (.container, .player-zone, .controls-zone) pour standardiser les espacements et marges. Préparer les emplacements avec des div conteneurs commentés et des classes CSS prêtes pour l'intégration future des composants timeline, loop-controls, et speed-control. Optimiser la hiérarchie visuelle avec une mise en page centrée sur la vidéo comme élément principal. Assurer la compatibilité avec les composants existants sans modification de leur API.",
        "testStrategy": "Vérifier l'intégration correcte des composants UrlInputComponent et VideoPlayerComponent, tester la responsivité sur tous les breakpoints (mobile, tablet, desktop), valider l'affichage cohérent du thème dark/light, contrôler que les zones préparées sont correctement positionnées et dimensionnées, tester la navigation entre saisie URL et lecture vidéo, vérifier que le layout s'adapte aux différentes orientations d'écran, valider l'accessibilité avec navigation clavier, tester sur différents navigateurs (Chrome, Firefox, Safari, Edge).",
        "status": "done",
        "dependencies": [
          11
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer le composant AppMainComponent avec architecture modulaire",
            "description": "Créer AppMainComponent dans src/app/features/main-app/ avec structure modulaire selon les conventions du projet, incluant les zones d'interface définies (saisie URL, player, contrôles futurs) et l'intégration des composants existants.",
            "dependencies": [],
            "details": "Générer le composant AppMainComponent avec ng generate dans src/app/features/main-app/ui/app-main/. Définir la structure HTML avec CSS Grid pour organiser les zones : .url-input-zone (en haut), .player-zone (centre), .controls-zone (vide pour futurs composants), .footer-zone (discret). Créer les fichiers index.ts selon la convention du projet. Importer et intégrer UrlInputComponent et VideoPlayerComponent existants. Créer les barrel exports nécessaires dans src/app/features/main-app/index.ts.",
            "status": "done",
            "testStrategy": "Vérifier la génération correcte du composant, la structure HTML avec CSS Grid, l'intégration des composants existants UrlInputComponent et VideoPlayerComponent, et la création des fichiers index.ts avec barrel exports."
          },
          {
            "id": 2,
            "title": "Implémenter le système de design modulaire avec CSS Grid et custom properties",
            "description": "Créer le système CSS Grid responsive avec zones bien définies et utiliser les custom properties existantes pour maintenir la cohérence avec le thème dark/light.",
            "dependencies": [
              "12.1"
            ],
            "details": "Dans app-main.component.scss, implémenter CSS Grid avec grid-template-areas pour définir les zones (url-input, player, controls, footer). Utiliser les variables CSS existantes du fichier styles.scss (--spacing-*, --background-*, --border-*). Créer des classes container réutilisables (.container, .player-zone, .controls-zone) avec espacements standardisés. Assurer la compatibilité avec le système de thème existant (dark/light).",
            "status": "done",
            "testStrategy": "Vérifier la mise en page avec CSS Grid, l'utilisation correcte des custom properties existantes, l'affichage cohérent en mode dark et light, et la réutilisabilité des classes container."
          },
          {
            "id": 3,
            "title": "Implémenter l'architecture responsive mobile-first avec breakpoints",
            "description": "Créer le design responsive avec breakpoints mobile (<768px), tablet (768px-1024px), desktop (>1024px) et optimiser la hiérarchie visuelle centrée sur la vidéo.",
            "dependencies": [
              "12.2"
            ],
            "details": "Définir les breakpoints dans app-main.component.scss : mobile (<768px), tablet (768px-1024px), desktop (>1024px). Adapter la grille CSS Grid pour chaque breakpoint (colonne unique mobile, grille adaptée tablet/desktop). Optimiser les tailles et espacements pour chaque format. Centrer la vidéo comme élément principal de l'interface. Gérer les orientations portrait/paysage sur tablette.",
            "status": "done",
            "testStrategy": "Tester l'affichage sur différentes tailles d'écran (mobile, tablet, desktop), vérifier la réorganisation de la grille selon les breakpoints, valider le centrage de la vidéo et l'optimisation des espaces."
          },
          {
            "id": 4,
            "title": "Préparer les zones pour les futurs composants avec containers commentés",
            "description": "Créer les emplacements prêts pour l'intégration future des composants timeline, loop-controls et speed-control avec des conteneurs commentés et classes CSS préparées.",
            "dependencies": [
              "12.3"
            ],
            "details": "Dans le template app-main.component.html, ajouter des div conteneurs commentés dans la .controls-zone pour timeline-component, loop-controls-component, et speed-control-component. Créer les classes CSS correspondantes (.timeline-container, .loop-controls-container, .speed-controls-container) avec dimensionnement et positionnement préparés. Ajouter des commentaires explicatifs dans le code pour l'intégration future. Préparer l'API d'intégration avec des propriétés/méthodes placeholder commentées.",
            "status": "done",
            "testStrategy": "Vérifier la présence des conteneurs commentés dans le HTML, les classes CSS préparées avec dimensions appropriées, la structure prête pour l'intégration future sans impact sur l'affichage actuel."
          },
          {
            "id": 5,
            "title": "Remplacer TestYouTubeComponent par AppMainComponent dans MainLayoutComponent",
            "description": "Modifier MainLayoutComponent pour utiliser AppMainComponent à la place de TestYouTubeComponent et assurer la compatibilité avec l'architecture existante.",
            "dependencies": [
              "12.1",
              "12.2",
              "12.3",
              "12.4"
            ],
            "details": "Dans main-layout.component.ts, remplacer l'import TestYouTubeComponent par AppMainComponent. Mettre à jour le tableau imports et le template main-layout.component.html pour utiliser <app-main></app-main> à la place de <app-test-youtube></app-test-youtube>. Vérifier que l'intégration respecte la structure existante du layout et les styles CSS. Préserver la fonctionnalité du header avec theme toggle et footer.",
            "status": "done",
            "testStrategy": "Vérifier le remplacement correct dans main-layout.component.ts et le template, s'assurer que l'application fonctionne sans erreur avec le nouveau composant, valider que le header et footer restent fonctionnels, et tester l'intégration des composants UrlInputComponent et VideoPlayerComponent."
          }
        ]
      },
      {
        "id": 13,
        "title": "Connecter la timeline interactive avec le service de boucles pour une lecture automatique",
        "description": "Implémenter la liaison entre TimelineComponent et LoopService pour que les changements des poignées draggables mettent automatiquement à jour les bornes de boucle et activent la surveillance de boucle en temps réel avec contrôle automatique de la position de lecture.",
        "status": "done",
        "dependencies": [
          12
        ],
        "priority": "medium",
        "details": "Intégrer TimelineComponent avec LoopService en créant une communication bidirectionnelle via Angular Signals. Implémenter l'écoute des événements drag des poignées start/end pour mettre à jour automatiquement les bornes via loopService.setLoopBounds(). Activer automatiquement loop.isActive = true dès qu'une borne est modifiée. NOUVEAU : Lors du drag de la poignée start, positionner automatiquement la lecture vidéo sur cette position via YouTubePlayerService.seekTo(). Lors du déclenchement de play, démarrer la lecture depuis startTime et implémenter la boucle automatique entre start et end. Synchroniser l'affichage visual de la timeline avec l'état du LoopService. Implémenter la logique de validation des bornes (start < end, bornes dans les limites de la vidéo). Ajouter des debounce pour éviter les appels excessifs lors du drag. Gérer les cas edge : vidéo non chargée, bornes invalides, changement de vidéo. Utiliser computed() pour synchroniser l'état visual avec les données du service. Implémenter des animations CSS smooth pour les transitions des poignées.",
        "testStrategy": "Tester le drag des poignées start/end et vérifier que les bornes sont mises à jour dans LoopService, NOUVEAU : valider que le drag de la poignée start repositionne la lecture vidéo automatiquement, tester que le bouton play démarre la lecture depuis startTime défini, valider la boucle automatique entre start et end lors de la lecture, valider l'activation automatique de la boucle lors des changements, tester la synchronisation bidirectionnelle timeline ↔ service, vérifier la validation des bornes (start < end), tester le comportement avec vidéos de différentes durées, valider les cas edge (pas de vidéo, bornes invalides), tester les performances lors de drag intensif, vérifier l'affichage correct de la zone de boucle sur la timeline.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implémenter l'injection des services dans TimelineComponent",
            "description": "Intégrer LoopService et YouTubePlayerService dans TimelineComponent pour établir la communication bidirectionnelle",
            "dependencies": [],
            "details": "Injecter LoopService et YouTubePlayerService dans TimelineComponent via inject(). Créer des computed() signals pour synchroniser l'affichage des poignées avec loop.startTime et loop.endTime du service. Implémenter une méthode de validation des bornes qui vérifie que startTime < endTime et que les bornes sont dans la durée totale de la vidéo.",
            "status": "done",
            "testStrategy": "Vérifier que les services sont correctement injectés, tester que les computed signals reflètent les changements du LoopService, valider la logique de validation des bornes"
          },
          {
            "id": 2,
            "title": "Connecter les événements drag des poignées au LoopService",
            "description": "Implémenter la liaison entre les événements drag des poignées start/end et les méthodes de mise à jour du LoopService",
            "dependencies": [
              "13.1"
            ],
            "details": "Modifier les handlers d'événements drag pour appeler loopService.setLoopBounds(startTime, endTime) lors des changements. Implémenter un debounce de 100ms pour éviter les appels excessifs pendant le drag. Activer automatiquement loop.isActive = true dès qu'une borne est modifiée. Ajouter la validation des bornes avant la mise à jour du service.",
            "status": "done",
            "testStrategy": "Tester le drag des poignées et vérifier que LoopService est mis à jour, valider le debounce pendant le drag continu, confirmer que isActive devient true automatiquement"
          },
          {
            "id": 3,
            "title": "Implémenter le repositionnement automatique lors du drag de start",
            "description": "Ajouter la fonctionnalité de repositionnement automatique de la lecture vidéo lors du drag de la poignée start",
            "dependencies": [
              "13.2"
            ],
            "details": "Modifier le handler de drag de la poignée start pour appeler youTubePlayerService.seekTo() avec la nouvelle position. Implémenter une logique de debounce spécifique pour seekTo (200ms) pour éviter les appels trop fréquents à l'API YouTube. Gérer les cas où la vidéo n'est pas encore chargée ou en état de pause. Ajouter un feedback visuel pendant le repositionnement.",
            "status": "done",
            "testStrategy": "Valider que le drag de la poignée start repositionne automatiquement la lecture, tester le debounce pour éviter les appels excessifs à seekTo, vérifier le comportement avec une vidéo en pause"
          },
          {
            "id": 4,
            "title": "Synchroniser l'affichage visuel avec l'état du LoopService",
            "description": "Implémenter la synchronisation complète entre l'affichage visuel des poignées et l'état du LoopService",
            "dependencies": [
              "13.2"
            ],
            "details": "Utiliser computed() pour calculer les positions visuelles des poignées basées sur loop.startTime et loop.endTime. Implémenter la zone colorée dynamique entre les poignées basée sur l'état isActive. Ajouter des animations CSS smooth pour les transitions des poignées lors des changements programmatiques. Gérer l'affichage des temps au-dessus des poignées avec formatage approprié (MM:SS).",
            "status": "done",
            "testStrategy": "Vérifier que les poignées se déplacent automatiquement lors des changements dans LoopService, tester l'affichage de la zone colorée, valider les animations smooth des transitions"
          },
          {
            "id": 5,
            "title": "Gérer les cas edge et finaliser l'intégration",
            "description": "Implémenter la gestion des cas edge et finaliser l'intégration complète entre timeline et services",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "Gérer les cas où la vidéo n'est pas encore chargée (désactiver les interactions). Implémenter la réinitialisation des bornes lors du changement de vidéo. Ajouter la gestion d'erreur pour les appels à seekTo() qui échouent. Implémenter la logique de nettoyage des timers et subscriptions dans ngOnDestroy(). Ajouter des logs de debug pour faciliter le débogage en développement.",
            "status": "done",
            "testStrategy": "Tester avec une vidéo non chargée, valider le comportement lors du changement de vidéo, vérifier la gestion des erreurs seekTo(), confirmer le nettoyage des ressources"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-09-07T19:39:54.188Z",
      "updated": "2025-09-14T20:14:12.635Z",
      "description": "Tasks for master context"
    }
  },
  "audio-looper": {
    "tasks": [
      {
        "id": 1,
        "title": "Mise en place de la navigation entre modules YouTube Looper et Audio Looper",
        "description": "Créer un système de navigation (onglets ou boutons) permettant de basculer entre les modules YouTube Looper existant et le nouveau module Audio Looper",
        "details": "Implémenter un composant de navigation avec deux onglets/boutons: 'YouTube Looper' et 'Audio Looper'. Utiliser Angular Router pour la navigation entre les modules. Créer les routes appropriées dans app.routes.ts. Ajouter les styles SCSS pour les onglets avec état actif/inactif. Assurer une navigation fluide sans rechargement de page. Positionner la navigation en haut de l'application selon le mockup fourni.",
        "testStrategy": "Vérifier que les onglets sont visibles en haut de l'application, que le clic sur chaque onglet change la vue sans rechargement, que l'onglet actif est visuellement distinct, et que la navigation fonctionne sur mobile et desktop.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T07:05:42.042Z"
      },
      {
        "id": 2,
        "title": "Création de la structure de base du module Audio Looper",
        "description": "Créer l'architecture de base du module Audio Looper avec les composants principaux et la structure de dossiers recommandée",
        "details": "Créer la structure de dossiers selon l'architecture Angular suggérée dans src/app/features/audio-looper/. Générer les composants principaux: audio-looper-container, file-upload, audio-player, loop-controls, pitch-control, speed-control, volume-control. Chaque composant doit avoir son propre dossier avec fichiers .ts, .html, .scss et index.ts. Implémenter les barrel exports dans tous les index.ts. Créer les services de base: audio-player.service.ts, tone-engine.service.ts, waveform.service.ts. Utiliser strictement les standalone components Angular 19.2.",
        "testStrategy": "Vérifier que tous les composants sont générés correctement, que la structure de dossiers respecte les conventions, que les imports via barrel exports fonctionnent, et que l'application compile sans erreur avec ng build.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T09:43:29.007Z"
      },
      {
        "id": 3,
        "title": "Installation et configuration de Tone.js",
        "description": "Installer Tone.js et configurer l'environnement audio pour le traitement des fichiers audio",
        "details": "Installer les dépendances: npm install tone et npm install --save-dev @types/tone. Créer le service tone-engine.service.ts avec les méthodes de base pour initialiser le contexte audio Tone.js. Implémenter les méthodes pour charger un fichier audio, contrôler la lecture (play/pause), et gérer le volume. Configurer le service comme singleton avec inject() selon les conventions Angular. Ajouter la gestion d'erreurs pour les cas où l'audio n'est pas supporté par le navigateur.",
        "testStrategy": "Vérifier que Tone.js est correctement installé, que le service s'initialise sans erreur, que le contexte audio se démarre correctement (gestion des politiques autoplay), et qu'un fichier audio basique peut être chargé via Tone.Player.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T10:08:02.189Z"
      },
      {
        "id": 4,
        "title": "Implémentation du composant d'upload centré en mode vide",
        "description": "Créer le composant file-upload avec zone drag & drop centrée et validation des fichiers audio",
        "details": "Implémenter le composant file-upload avec zone de drag & drop et bouton 'Parcourir'. Centrer verticalement et horizontalement la zone d'upload quand aucun fichier n'est chargé (selon mockup). Valider les formats supportés: MP3, WAV, OGG, M4A. Limiter la taille à 10 Mo (10 485 760 octets). Afficher des messages d'erreur clairs pour formats non supportés ou fichiers trop volumineux. Utiliser les directives Angular pour le drag & drop (dragover, dragleave, drop). Implémenter les styles SCSS responsive pour mobile/desktop avec zone tactile suffisante.",
        "testStrategy": "Tester le drag & drop de fichiers valides et invalides, vérifier les messages d'erreur, confirmer la limitation de taille, valider le centrage sur différentes tailles d'écran, et s'assurer que l'upload fonctionne sur mobile et desktop.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T10:43:12.111Z"
      },
      {
        "id": 5,
        "title": "Création du composant waveform-display pour visualisation de l'onde audio",
        "description": "Développer le composant central de visualisation de la forme d'onde audio avec Canvas API",
        "details": "Créer le composant waveform-display comme élément graphique principal. Utiliser Canvas API ou wavesurfer.js pour générer et afficher la forme d'onde. Implémenter la méthode de génération de waveform à partir d'un fichier audio chargé via Tone.js. Dimensionner le canvas pour être responsive et touch-friendly (minimum 48px de hauteur sur mobile). Créer le service waveform.service.ts pour la logique de génération et de rendu. Optimiser les performances pour des fichiers jusqu'à 10 MB. Ajouter un loader pendant la génération de la waveform (moins d'1 seconde requis).",
        "testStrategy": "Vérifier que la waveform s'affiche correctement après upload d'un fichier audio, que la génération prend moins d'1 seconde, que le canvas est responsive sur tous les écrans, et que la visualisation est claire et lisible.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T11:27:55.525Z"
      },
      {
        "id": 6,
        "title": "Implémentation de la révélation progressive de l'interface",
        "description": "Créer le système de transition fluide entre l'état vide (upload centré) et l'état chargé (waveform + contrôles)",
        "details": "Implémenter la logique de révélation progressive dans audio-looper-container. En mode vide: afficher uniquement la zone d'upload centrée. Après chargement réussi: animation de transition pour faire apparaître la waveform au centre et les contrôles autour. Minimiser la zone d'upload vers le haut avec nom du fichier et bouton 'Change File'. Utiliser les animations CSS/Angular pour les transitions fluides. Gérer les états: vide, chargement, chargé, erreur. Appliquer les styles selon le mockup fourni avec layout adaptatif.",
        "testStrategy": "Vérifier les transitions fluides entre états, valider que l'upload se minimise correctement après chargement, confirmer que les contrôles apparaissent progressivement, et tester l'expérience utilisateur complète sur mobile et desktop.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T13:43:01.161Z"
      },
      {
        "id": 7,
        "title": "Développement du lecteur audio de base avec curseur sur waveform",
        "description": "Implémenter les contrôles de lecture de base (play/pause) avec curseur de lecture animé sur la waveform",
        "details": "Créer le composant audio-player avec boutons Play/Pause. Implémenter l'affichage du temps courant et durée totale au format MM:SS. Développer le curseur de lecture comme ligne verticale se déplaçant sur la waveform en temps réel (60 FPS). Connecter le lecteur audio avec Tone.js Player. Synchroniser la position du curseur avec la position de lecture audio. Gérer les états play/pause avec feedback visuel immédiat. Optimiser les performances pour animation fluide du curseur.",
        "testStrategy": "Tester la lecture/pause, vérifier la synchronisation curseur-audio, valider l'affichage des temps, confirmer la fluidité de l'animation du curseur à 60 FPS, et s'assurer du bon fonctionnement sur mobile.",
        "priority": "high",
        "dependencies": [
          "6"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T14:08:42.553Z"
      },
      {
        "id": 8,
        "title": "Implémentation de la navigation directe sur la waveform",
        "description": "Permettre à l'utilisateur de cliquer sur la waveform pour se positionner à un instant précis",
        "details": "Ajouter la gestion des événements de clic sur le canvas de la waveform. Calculer la position temporelle en fonction de la position X du clic. Implémenter la méthode pour déplacer la lecture à la position cliquée via Tone.js. Optimiser pour le tactile mobile avec zone de touch suffisamment large. Ajouter un feedback visuel lors du clic (highlight temporaire). Gérer les cas limites (clic en dehors de la durée audio). Assurer une réactivité immédiate pour une expérience utilisateur fluide.",
        "testStrategy": "Tester les clics sur différentes parties de la waveform, vérifier la précision du positionnement temporel, valider l'interaction tactile sur mobile, et confirmer le feedback visuel lors des interactions.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-12T17:34:36.106Z"
      },
      {
        "id": 9,
        "title": "Création du système de boucle A/B avec marqueurs visuels",
        "description": "Implémenter les contrôles de boucle A/B avec marqueurs et zone colorée superposés sur la waveform",
        "details": "Développer le composant loop-controls avec boutons 'Set A', 'Set B', 'Loop ON/OFF', 'Reset Loop'. Implémenter les marqueurs visuels A et B comme lignes verticales colorées superposées sur la waveform. Créer la zone colorée entre A et B directement sur l'onde audio (overlay). Intégrer avec Tone.js pour la lecture en boucle automatique (setLoopPoints). Gérer les états de boucle active/inactive avec indicateur visuel 'Loop Active'. Assurer que la lecture saute automatiquement de B vers A pendant la boucle.",
        "testStrategy": "Tester la définition des points A et B, vérifier l'affichage des marqueurs sur la waveform, valider la zone colorée entre A et B, confirmer la lecture en boucle automatique, et tester le reset des points.",
        "priority": "high",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implémentation du contrôle de tonalité (pitch shift)",
        "description": "Créer le composant de contrôle de la tonalité avec slider -6 à +6 demi-tons utilisant Tone.PitchShift",
        "details": "Développer le composant pitch-control avec slider ou input numérique pour la plage -6 à +6 demi-tons. Intégrer Tone.PitchShift dans le tone-engine.service pour modifier la tonalité en temps réel. Afficher la valeur courante (ex. '+3 demi-tons', '-5 demi-tons'). Implémenter le bouton 'Reset Pitch' pour revenir à 0. Appliquer les changements instantanément pendant la lecture. Optimiser les performances pour éviter les latences audibles. Utiliser les bonnes pratiques Tone.js pour les effets audio.",
        "testStrategy": "Tester le slider sur toute la plage -6 à +6, vérifier l'application en temps réel de la tonalité, valider l'affichage de la valeur courante, confirmer le fonctionnement du reset, et s'assurer de l'absence de latence perceptible.",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Développement du contrôle de vitesse avec presets et stepper",
        "description": "Créer le composant de contrôle de vitesse avec boutons presets (0.5x, 0.75x, 1.0x) et stepper précis (0.4x-2.0x)",
        "details": "Implémenter le composant speed-control avec boutons presets rapides: 0.5x, 0.75x, 1.0x. Développer le stepper [- | valeur | +] pour ajustements précis de 0.4x à 2.0x par incréments de 0.1x. Synchroniser les presets avec le stepper (clic preset met à jour le stepper). Utiliser Tone.js pour modifier la vitesse sans altérer la tonalité. Afficher la vitesse courante (ex. '0.6x', '1.2x'). Appliquer les changements en temps réel. Définir 1.0x comme vitesse par défaut au chargement.",
        "testStrategy": "Tester les boutons presets, valider le stepper sur toute la plage 0.4x-2.0x, vérifier la synchronisation preset-stepper, confirmer que la tonalité n'est pas altérée, et tester l'application en temps réel.",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implémentation du contrôle de volume avec slider et mute",
        "description": "Créer le composant de contrôle du volume avec slider 0-100% et bouton mute/unmute",
        "details": "Développer le composant volume-control avec slider de volume (0% à 100%). Implémenter le bouton mute/unmute avec icônes 🔊/🔇 (seul composant avec icônes selon les spécifications). Intégrer avec Tone.Volume ou player.volume.value dans tone-engine.service. Gérer les états muet/actif avec changement d'icône. Appliquer les changements de volume en temps réel. Mémoriser le niveau de volume avant mute pour restauration. Utiliser les styles SCSS cohérents avec l'application.",
        "testStrategy": "Tester le slider de volume sur toute la plage 0-100%, vérifier le fonctionnement mute/unmute, valider les changements d'icônes, confirmer l'application en temps réel, et tester la mémorisation du volume avant mute.",
        "priority": "medium",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Optimisation responsive et interactions tactiles",
        "description": "Optimiser l'interface pour mobile et tablette avec interactions tactiles améliorées",
        "details": "Adapter tous les composants pour responsive design (desktop 1920×1080 à 1280×720, tablet 768×1024, mobile 375×667 à 414×896). Optimiser la waveform pour interaction tactile avec zone minimum 48px de hauteur. Améliorer les contrôles pour usage tactile (taille des boutons, espacement). Tester en mode portrait et paysage. Assurer que l'onde audio reste le composant central sur toutes les tailles d'écran. Ajuster les styles SCSS avec breakpoints appropriés. Optimiser les performances sur appareils mobiles.",
        "testStrategy": "Tester sur différentes tailles d'écran (desktop, tablet, mobile), valider les interactions tactiles, vérifier le comportement en portrait/paysage, confirmer la lisibilité et ergonomie sur mobile, et tester les performances sur appareils mobiles.",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Finalisation des styles et cohérence visuelle",
        "description": "Finaliser les styles SCSS pour assurer la cohérence avec le module YouTube Looper et le design épuré",
        "details": "Harmoniser tous les styles SCSS avec ceux du module YouTube Looper existant. Appliquer le design minimaliste et épuré selon les spécifications. Implémenter les boutons textuels uniquement (sauf volume). Finaliser les états visuels (erreur, chargement, actif, inactif) pour qu'ils soient clairs. Optimiser la hiérarchie visuelle avec l'onde audio comme élément central. Ajuster les couleurs, typographie, espacement selon la charte graphique. Valider l'accessibilité et les contrastes.",
        "testStrategy": "Comparer visuellement avec le module YouTube Looper, vérifier la cohérence des styles, valider le design minimaliste, tester tous les états visuels, et confirmer la lisibilité sur différents écrans.",
        "priority": "low",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Tests manuels complets et optimisations finales",
        "description": "Effectuer les tests manuels complets de toutes les fonctionnalités et optimiser les performances",
        "details": "Effectuer des tests exhaustifs de tous les critères d'acceptation. Tester avec différents formats de fichiers audio (MP3, WAV, OGG, M4A). Valider les performances: chargement <2s pour 10MB, génération waveform <1s, effets temps réel sans latence, animation curseur 60 FPS. Vérifier la gestion d'erreurs avec fichiers corrompus ou non supportés. Tester la lecture en boucle fluide sans coupures. Optimiser le code pour les performances finales. Corriger les bugs identifiés lors des tests.",
        "testStrategy": "Effectuer une checklist complète des critères d'acceptation, mesurer les performances avec chronomètre, tester avec fichiers de différentes tailles et formats, valider tous les cas d'erreur, et confirmer que toutes les fonctionnalités répondent aux spécifications.",
        "priority": "high",
        "dependencies": [
          "14"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-12T17:34:36.108Z",
      "taskCount": 15,
      "completedCount": 8,
      "tags": [
        "audio-looper"
      ],
      "created": "2025-10-14T16:01:57.210Z",
      "description": "Tasks for audio-looper context",
      "updated": "2025-10-14T16:01:57.210Z"
    }
  },
  "rubberband-wasm-pitch": {
    "tasks": [
      {
        "id": "1",
        "title": "Préparation des assets statiques rubberband-wasm",
        "description": "Copier les fichiers rubberband.wasm et rubberband.umd.min.js dans public/assets/rubberband/ et vérifier leur accessibilité après build",
        "details": "Créer le dossier public/assets/rubberband/ et y copier les fichiers depuis .ai/rubberband-wasm/: rubberband.wasm (265 KB) et rubberband.umd.min.js (6.7 KB). Vérifier dans angular.json que les assets sont correctement configurés pour être copiés vers dist/assets/rubberband/. Tester l'accessibilité des fichiers après ng build en vérifiant qu'ils sont présents dans dist/assets/rubberband/.",
        "testStrategy": "Lancer ng build et vérifier que les fichiers rubberband.wasm et rubberband.umd.min.js sont présents dans dist/assets/rubberband/. Accéder aux URLs /assets/rubberband/rubberband.wasm et /assets/rubberband/rubberband.umd.min.js via le serveur de développement.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-17T17:02:30.535Z"
      },
      {
        "id": "2",
        "title": "Création des interfaces TypeScript pour le Web Worker",
        "description": "Créer les types TypeScript pour les messages d'entrée et de sortie du Web Worker rubberband",
        "details": "Créer le fichier src/app/features/audio-looper/services/workers/rubberband-worker.types.ts avec les interfaces RubberbandWorkerInput (channelBuffers: Float32Array[], sampleRate: number, pitch: number, tempo: number) et RubberbandWorkerOutput (channelBuffers?: Float32Array[], ready?: boolean, status?: string, progress?: number, error?: string). Créer aussi le fichier index.ts pour exporter les types.",
        "testStrategy": "Vérifier que les types sont correctement exportés et importables. Compiler le projet avec ng build pour s'assurer qu'il n'y a pas d'erreurs TypeScript.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2025-10-17T17:09:54.329Z"
      },
      {
        "id": "3",
        "title": "Implémentation du Web Worker rubberband",
        "description": "Créer le Web Worker qui charge rubberband-wasm et traite l'audio avec les phases Study et Process",
        "details": "Créer src/app/features/audio-looper/services/workers/rubberband.worker.ts. Implémenter le chargement asynchrone de rubberband-wasm via importScripts, l'initialisation du module avec locateFile pointant vers /assets/rubberband/. Implémenter le traitement audio avec phase Study (0-50%) et phase Process (50-100%), throttling des messages de progression (250ms), et gestion des erreurs. Utiliser la logique inspirée de .ai/rubberband-wasm/worker.js.",
        "testStrategy": "Tester le Worker isolément en envoyant un message de test et vérifier qu'il charge rubberband-wasm correctement (message ready: true). Tester le traitement d'un buffer audio simple avec des console.logs pour vérifier les phases Study et Process.",
        "priority": "high",
        "dependencies": [
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Créer la structure du fichier Web Worker rubberband",
            "description": "Créer le fichier rubberband.worker.ts avec la structure de base et les interfaces TypeScript",
            "dependencies": [],
            "details": "Créer src/app/features/audio-looper/services/workers/rubberband.worker.ts avec les interfaces pour les messages entrants et sortants (RubberbandWorkerMessage, RubberbandWorkerResponse). Définir les types pour les commandes (LOAD, PROCESS) et les réponses (READY, PROGRESS, COMPLETE, ERROR). Implémenter la structure de base du Worker avec addEventListener('message') et la fonction postMessage.",
            "status": "done",
            "testStrategy": "Vérifier que le fichier TypeScript compile sans erreur et que la structure de base du Worker est correctement définie.",
            "updatedAt": "2025-10-17T17:34:15.950Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implémenter le chargement asynchrone de rubberband-wasm",
            "description": "Ajouter la logique de chargement du module WebAssembly avec importScripts et initialisation",
            "dependencies": [
              1
            ],
            "details": "Implémenter la fonction loadRubberbandModule() qui utilise importScripts pour charger rubberband-wasm depuis /assets/rubberband/. Configurer le module avec locateFile pointant vers le bon répertoire des assets. Gérer les erreurs de chargement et envoyer un message READY au thread principal une fois l'initialisation terminée. S'inspirer de la logique dans .ai/rubberband-wasm/worker.js.",
            "status": "done",
            "testStrategy": "Tester le Worker en envoyant un message de test et vérifier qu'il répond avec ready: true après avoir chargé rubberband-wasm correctement.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T17:34:19.282Z"
          },
          {
            "id": 3,
            "title": "Implémenter la phase Study du traitement audio",
            "description": "Créer la logique de la phase Study qui analyse l'audio avant le traitement (0-50% du progrès)",
            "dependencies": [
              2
            ],
            "details": "Implémenter la fonction processStudyPhase() qui utilise l'API rubberband pour analyser le buffer audio. Configurer les paramètres pitch et tempo reçus dans le message. Implémenter les callbacks de progression pour la phase Study (0% à 50%). Utiliser un throttling de 250ms pour les messages de progression. Gérer les erreurs spécifiques à cette phase et les communiquer au thread principal.",
            "status": "done",
            "testStrategy": "Tester avec un buffer audio simple et vérifier que les messages de progression sont envoyés correctement entre 0% et 50%. Vérifier les console.logs pour s'assurer que la phase Study s'exécute.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T17:34:22.379Z"
          },
          {
            "id": 4,
            "title": "Implémenter la phase Process du traitement audio",
            "description": "Créer la logique de la phase Process qui génère l'audio traité (50-100% du progrès)",
            "dependencies": [
              3
            ],
            "details": "Implémenter la fonction processProcessPhase() qui génère le buffer audio final avec les modifications de pitch et tempo. Continuer les callbacks de progression pour la phase Process (50% à 100%). Récupérer le buffer audio traité et l'envoyer au thread principal via un message COMPLETE. Implémenter la gestion mémoire pour libérer les ressources utilisées par rubberband après traitement.",
            "status": "done",
            "testStrategy": "Tester le traitement complet d'un buffer audio et vérifier que le buffer final est retourné. Vérifier que les messages de progression vont bien de 50% à 100% et que la phase Process s'exécute correctement.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T17:34:25.457Z"
          },
          {
            "id": 5,
            "title": "Implémenter la gestion des erreurs et l'orchestration générale",
            "description": "Ajouter la gestion complète des erreurs et coordonner les phases Study et Process",
            "dependencies": [
              4
            ],
            "details": "Implémenter la fonction principale processAudio() qui orchestre les phases Study et Process en séquence. Ajouter la gestion globale des erreurs avec try-catch et messages ERROR appropriés. Implémenter le throttling des messages de progression à 250ms maximum. Ajouter la validation des paramètres d'entrée (buffer, pitch, tempo) et la gestion des cas d'erreur. Nettoyer les ressources et gérer l'arrêt propre du Worker.",
            "status": "done",
            "testStrategy": "Tester les cas d'erreur (paramètres invalides, échec de chargement) et vérifier que les messages ERROR sont envoyés. Tester le traitement complet et s'assurer que toutes les ressources sont libérées correctement.",
            "parentId": "undefined",
            "updatedAt": "2025-10-17T17:34:28.603Z"
          }
        ],
        "updatedAt": "2025-10-17T17:34:28.603Z"
      },
      {
        "id": "4",
        "title": "Création du RubberbandEngineService",
        "description": "Créer le service Angular qui orchestre le traitement audio via le Web Worker avec cache et debounce",
        "details": "Créer src/app/features/audio-looper/services/rubberband-engine.service.ts avec injection Injectable providedIn: 'root'. Implémenter les signals pitch, playbackRate, isProcessing, processingProgress, processingStatus. Implémenter le cache Map<string, AudioBuffer> avec clés basées sur pitch et tempo. Implémenter le debounce 500ms pour éviter les traitements multiples. Créer l'API publique: loadOriginalBuffer(), setPitch(), setPlaybackRate(), getProcessedBuffer() Observable, clearCache().",
        "testStrategy": "Tester l'injection du service, la mise à jour des signals, le fonctionnement du cache (même paramètres = pas de retraitement), et le debounce en modifiant rapidement le pitch. Vérifier que getProcessedBuffer() émet correctement les buffers traités.",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "5",
        "title": "Intégration RubberbandEngineService dans ToneEngineService",
        "description": "Modifier ToneEngineService pour injecter RubberbandEngineService et gérer le remplacement de buffer",
        "details": "Dans src/app/features/audio-looper/services/tone-engine.service.ts, injecter RubberbandEngineService. Ajouter la propriété originalAudioBuffer pour stocker le buffer original. Modifier loadAudioFile() pour envoyer le buffer à rubberband via loadOriginalBuffer() et s'abonner à getProcessedBuffer(). Implémenter replaceAudioBuffer() qui préserve la position de lecture et l'état playing/paused lors du remplacement. Implémenter adjustLoopPoints() pour ajuster les marqueurs A/B selon la nouvelle durée.",
        "testStrategy": "Tester le chargement d'un fichier audio et vérifier que le buffer original est envoyé à rubberband. Tester le remplacement de buffer en s'assurant que la position de lecture et l'état sont conservés. Vérifier que les marqueurs A/B restent valides après traitement.",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "6",
        "title": "Création du composant RubberbandPitchControlComponent",
        "description": "Créer le composant UI pour le contrôle du pitch avec slider et indicateur de progression",
        "details": "Créer src/app/features/audio-looper/ui/rubberband-pitch-control/ avec les fichiers component.ts, component.html, component.scss et index.ts. Implémenter le template avec slider -6 à +6, affichage de la valeur courante, bouton Reset Pitch, et indicateur de progression conditionnel (@if). Injecter ToneEngineService et RubberbandEngineService. Implémenter onPitchChange() qui appelle toneEngine.setPitch(). Utiliser les signals pour l'affichage réactif.",
        "testStrategy": "Tester l'affichage du composant, le fonctionnement du slider, la mise à jour de la valeur affichée, le bouton Reset, et l'apparition/disparition de l'indicateur de progression pendant le traitement.",
        "priority": "medium",
        "dependencies": [
          "5"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "7",
        "title": "Styling SCSS du composant RubberbandPitchControlComponent",
        "description": "Implémenter les styles SCSS pour le contrôle pitch avec design responsive et indicateur de progression",
        "details": "Dans rubberband-pitch-control.component.scss, créer les styles pour .pitch-control avec header (label + valeur), slider-container, bouton reset, et section processing. Implémenter la barre de progression animée avec .progress-bar et .progress-fill. Assurer la cohérence avec les styles existants du module audio-looper. Implémenter le responsive design pour mobile, tablette et desktop. Utiliser les variables SCSS existantes si disponibles.",
        "testStrategy": "Tester l'affichage sur différentes tailles d'écran (mobile, tablette, desktop). Vérifier que l'indicateur de progression s'anime correctement et que les contrôles sont utilisables sur écran tactile. Vérifier la cohérence visuelle avec les autres composants du module.",
        "priority": "medium",
        "dependencies": [
          "6"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "8",
        "title": "Intégration du composant dans AudioLooperContainerComponent",
        "description": "Ajouter RubberbandPitchControlComponent dans le template du container principal",
        "details": "Dans src/app/features/audio-looper/ui/audio-looper-container/audio-looper-container.component.html, ajouter <app-rubberband-pitch-control></app-rubberband-pitch-control> après le commentaire '<!-- Les autres contrôles seront ajoutés dans les prochaines tâches -->'. Importer le composant dans audio-looper-container.component.ts via le fichier index.ts. Vérifier que le composant s'affiche correctement dans l'interface.",
        "testStrategy": "Charger l'application, naviguer vers le module Audio Looper, et vérifier que le contrôle pitch rubberband s'affiche correctement dans la section des contrôles. Tester l'interaction avec le slider et vérifier qu'il n'y a pas d'erreurs dans la console.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "9",
        "title": "Modification de WaveformDisplayComponent pour la régénération",
        "description": "Modifier WaveformDisplayComponent pour régénérer automatiquement la waveform lors du changement de buffer",
        "details": "Dans src/app/features/audio-looper/ui/waveform-display/waveform-display.component.ts, ajouter un effect() qui écoute les changements de duration du ToneEngineService. Implémenter regenerateWaveform() qui récupère le nouveau buffer via this.player.buffer.get() et redessine la waveform. Conserver les marqueurs A/B et la position du curseur de lecture. Utiliser effect() d'Angular pour réagir automatiquement aux changements.",
        "testStrategy": "Charger un fichier audio, modifier le pitch, et vérifier que la waveform se régénère automatiquement après le traitement. Vérifier que les marqueurs A/B et le curseur de lecture restent aux bonnes positions. Tester avec différents changements de pitch.",
        "priority": "medium",
        "dependencies": [
          "8"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "10",
        "title": "Implémentation du cache et optimisation des performances",
        "description": "Optimiser le système de cache du RubberbandEngineService et améliorer les performances",
        "details": "Dans rubberband-engine.service.ts, optimiser la logique de cache avec getCacheKey() basé sur pitch et tempo. Implémenter clearCache() pour la gestion mémoire. Optimiser le debounce pour éviter les traitements inutiles. Ajouter la gestion de l'annulation des traitements en cours (Worker.terminate()). Implémenter le throttling des messages de progression (250ms) côté service.",
        "testStrategy": "Tester le cache en changeant plusieurs fois le pitch et en revenant aux valeurs précédentes (doit être instantané). Tester l'annulation en changeant rapidement le pitch plusieurs fois. Vérifier que les performances restent fluides même avec des fichiers de 10MB.",
        "priority": "medium",
        "dependencies": [
          "9"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "11",
        "title": "Gestion des erreurs et fallback",
        "description": "Implémenter la gestion d'erreurs pour le chargement de rubberband-wasm et le traitement audio",
        "details": "Ajouter la gestion d'erreurs dans le Web Worker pour le chargement de rubberband-wasm (fichiers manquants, erreurs WASM). Dans RubberbandEngineService, implémenter la gestion des erreurs de traitement et des timeouts. Ajouter des messages d'erreur utilisateur clairs dans le composant UI. Implémenter un fallback vers Tone.js PitchShift en cas d'échec de rubberband. Ajouter des logs console pour le debugging.",
        "testStrategy": "Tester avec des fichiers corrompus, simuler l'indisponibilité des assets rubberband, et vérifier que l'application reste utilisable avec des messages d'erreur clairs. Vérifier que le fallback vers Tone.js fonctionne correctement.",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "12",
        "title": "Tests de compatibilité cross-browser et WebAssembly",
        "description": "Tester la compatibilité rubberband-wasm sur différents navigateurs et implémenter les détections nécessaires",
        "details": "Tester rubberband-wasm sur Chrome, Firefox, Safari et Edge. Implémenter la détection du support WebAssembly au démarrage. Ajouter des messages informatifs si WebAssembly n'est pas supporté. Tester sur mobile (iOS Safari, Chrome Android). Implémenter des polyfills si nécessaire. Vérifier les performances sur différentes plateformes.",
        "testStrategy": "Tester l'application sur Chrome, Firefox, Safari et Edge (desktop et mobile). Vérifier que rubberband-wasm se charge correctement et que le traitement audio fonctionne. Tester sur des appareils moins puissants pour vérifier les performances.",
        "priority": "medium",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "13",
        "title": "Synchronisation avec les autres contrôles audio",
        "description": "Assurer la compatibilité entre le pitch rubberband et les autres contrôles (vitesse, volume, loop)",
        "details": "Vérifier que le contrôle de vitesse (playback rate) fonctionne correctement avec les buffers traités par rubberband. Tester la compatibilité avec le contrôle de volume et les marqueurs de boucle A/B. Implémenter la synchronisation entre ToneEngineService et RubberbandEngineService pour éviter les conflits. Tester les interactions entre tous les contrôles audio simultanément.",
        "testStrategy": "Charger un fichier, modifier le pitch avec rubberband, puis tester tous les autres contrôles (vitesse 0.5x/0.75x/1.0x, volume, boucle A/B, lecture/pause, seek). Vérifier qu'il n'y a pas de conflits ou de comportements inattendus.",
        "priority": "medium",
        "dependencies": [
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "14",
        "title": "Tests de qualité audio et validation des algorithmes",
        "description": "Effectuer des tests approfondis de qualité audio pour valider l'amélioration par rapport à Tone.js",
        "details": "Tester le pitch shift de -6 à +6 demi-tons avec différents types de fichiers audio (voix, musique, instruments). Comparer la qualité audio entre Tone.js PitchShift et rubberband-wasm. Vérifier l'absence d'artefacts (distorsion, phasing, effet chipmunk). Tester avec des fichiers de différentes qualités (MP3 128kbps, 320kbps, WAV). Documenter les améliorations de qualité observées.",
        "testStrategy": "Préparer des fichiers de test variés (guitare, piano, voix, musique complète). Tester chaque valeur de pitch (-6 à +6) et comparer avec Tone.js. Écouter attentivement pour détecter les artefacts. Faire valider la qualité audio par un utilisateur musical si possible.",
        "priority": "high",
        "dependencies": [
          "13"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "15",
        "title": "Documentation et nettoyage du code",
        "description": "Ajouter la documentation technique, nettoyer le code et effectuer la validation finale",
        "details": "Ajouter des commentaires JSDoc aux méthodes principales de RubberbandEngineService et du Web Worker. Nettoyer les console.logs de debug. Optimiser les imports et vérifier qu'il n'y a pas de code mort. Mettre à jour les fichiers index.ts pour les exports. Effectuer un build de production final et vérifier les performances. Préparer un commit atomique avec un message détaillé.",
        "testStrategy": "Lancer ng build --configuration production et vérifier qu'il n'y a aucune erreur. Tester l'application buildée pour s'assurer que toutes les fonctionnalités marchent en mode production. Vérifier que la taille du bundle reste raisonnable avec l'ajout de rubberband-wasm.",
        "priority": "low",
        "dependencies": [
          "14"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-10-17T17:34:28.606Z",
      "taskCount": 15,
      "completedCount": 3,
      "tags": [
        "rubberband-wasm-pitch"
      ]
    }
  }
}